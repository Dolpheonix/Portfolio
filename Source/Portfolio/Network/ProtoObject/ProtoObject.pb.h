// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoObject.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ProtoObject_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ProtoObject_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ProtoObject_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ProtoObject_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ProtoObject_2eproto;
namespace ProtoObject {
class Equipment;
struct EquipmentDefaultTypeInternal;
extern EquipmentDefaultTypeInternal _Equipment_default_instance_;
class GameItem;
struct GameItemDefaultTypeInternal;
extern GameItemDefaultTypeInternal _GameItem_default_instance_;
class Inventory;
struct InventoryDefaultTypeInternal;
extern InventoryDefaultTypeInternal _Inventory_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class LoginInfo;
struct LoginInfoDefaultTypeInternal;
extern LoginInfoDefaultTypeInternal _LoginInfo_default_instance_;
class MapTransition;
struct MapTransitionDefaultTypeInternal;
extern MapTransitionDefaultTypeInternal _MapTransition_default_instance_;
class Nickname;
struct NicknameDefaultTypeInternal;
extern NicknameDefaultTypeInternal _Nickname_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class QuestStatus;
struct QuestStatusDefaultTypeInternal;
extern QuestStatusDefaultTypeInternal _QuestStatus_default_instance_;
class QuestStatus_SubQuestStatus;
struct QuestStatus_SubQuestStatusDefaultTypeInternal;
extern QuestStatus_SubQuestStatusDefaultTypeInternal _QuestStatus_SubQuestStatus_default_instance_;
class RepBoolean;
struct RepBooleanDefaultTypeInternal;
extern RepBooleanDefaultTypeInternal _RepBoolean_default_instance_;
class ResourceChange;
struct ResourceChangeDefaultTypeInternal;
extern ResourceChangeDefaultTypeInternal _ResourceChange_default_instance_;
class TypeInventory;
struct TypeInventoryDefaultTypeInternal;
extern TypeInventoryDefaultTypeInternal _TypeInventory_default_instance_;
}  // namespace ProtoObject
PROTOBUF_NAMESPACE_OPEN
template<> ::ProtoObject::Equipment* Arena::CreateMaybeMessage<::ProtoObject::Equipment>(Arena*);
template<> ::ProtoObject::GameItem* Arena::CreateMaybeMessage<::ProtoObject::GameItem>(Arena*);
template<> ::ProtoObject::Inventory* Arena::CreateMaybeMessage<::ProtoObject::Inventory>(Arena*);
template<> ::ProtoObject::Location* Arena::CreateMaybeMessage<::ProtoObject::Location>(Arena*);
template<> ::ProtoObject::LoginInfo* Arena::CreateMaybeMessage<::ProtoObject::LoginInfo>(Arena*);
template<> ::ProtoObject::MapTransition* Arena::CreateMaybeMessage<::ProtoObject::MapTransition>(Arena*);
template<> ::ProtoObject::Nickname* Arena::CreateMaybeMessage<::ProtoObject::Nickname>(Arena*);
template<> ::ProtoObject::PlayerInfo* Arena::CreateMaybeMessage<::ProtoObject::PlayerInfo>(Arena*);
template<> ::ProtoObject::QuestStatus* Arena::CreateMaybeMessage<::ProtoObject::QuestStatus>(Arena*);
template<> ::ProtoObject::QuestStatus_SubQuestStatus* Arena::CreateMaybeMessage<::ProtoObject::QuestStatus_SubQuestStatus>(Arena*);
template<> ::ProtoObject::RepBoolean* Arena::CreateMaybeMessage<::ProtoObject::RepBoolean>(Arena*);
template<> ::ProtoObject::ResourceChange* Arena::CreateMaybeMessage<::ProtoObject::ResourceChange>(Arena*);
template<> ::ProtoObject::TypeInventory* Arena::CreateMaybeMessage<::ProtoObject::TypeInventory>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ProtoObject {

enum Inventory_ItemType : int {
  Inventory_ItemType_CLOTH = 0,
  Inventory_ItemType_WEAPON = 1,
  Inventory_ItemType_ITEM = 2,
  Inventory_ItemType_Inventory_ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Inventory_ItemType_Inventory_ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Inventory_ItemType_IsValid(int value);
constexpr Inventory_ItemType Inventory_ItemType_ItemType_MIN = Inventory_ItemType_CLOTH;
constexpr Inventory_ItemType Inventory_ItemType_ItemType_MAX = Inventory_ItemType_ITEM;
constexpr int Inventory_ItemType_ItemType_ARRAYSIZE = Inventory_ItemType_ItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Inventory_ItemType_descriptor();
template<typename T>
inline const std::string& Inventory_ItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Inventory_ItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Inventory_ItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Inventory_ItemType_descriptor(), enum_t_value);
}
inline bool Inventory_ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Inventory_ItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Inventory_ItemType>(
    Inventory_ItemType_descriptor(), name, value);
}
enum QuestStatus_SubQuestStatus_SubQuestType : int {
  QuestStatus_SubQuestStatus_SubQuestType_ARRIVAL = 0,
  QuestStatus_SubQuestStatus_SubQuestType_HUNT = 1,
  QuestStatus_SubQuestStatus_SubQuestType_ITEM = 2,
  QuestStatus_SubQuestStatus_SubQuestType_ACTION = 3,
  QuestStatus_SubQuestStatus_SubQuestType_QuestStatus_SubQuestStatus_SubQuestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  QuestStatus_SubQuestStatus_SubQuestType_QuestStatus_SubQuestStatus_SubQuestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool QuestStatus_SubQuestStatus_SubQuestType_IsValid(int value);
constexpr QuestStatus_SubQuestStatus_SubQuestType QuestStatus_SubQuestStatus_SubQuestType_SubQuestType_MIN = QuestStatus_SubQuestStatus_SubQuestType_ARRIVAL;
constexpr QuestStatus_SubQuestStatus_SubQuestType QuestStatus_SubQuestStatus_SubQuestType_SubQuestType_MAX = QuestStatus_SubQuestStatus_SubQuestType_ACTION;
constexpr int QuestStatus_SubQuestStatus_SubQuestType_SubQuestType_ARRAYSIZE = QuestStatus_SubQuestStatus_SubQuestType_SubQuestType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestStatus_SubQuestStatus_SubQuestType_descriptor();
template<typename T>
inline const std::string& QuestStatus_SubQuestStatus_SubQuestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestStatus_SubQuestStatus_SubQuestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestStatus_SubQuestStatus_SubQuestType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestStatus_SubQuestStatus_SubQuestType_descriptor(), enum_t_value);
}
inline bool QuestStatus_SubQuestStatus_SubQuestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestStatus_SubQuestStatus_SubQuestType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestStatus_SubQuestStatus_SubQuestType>(
    QuestStatus_SubQuestStatus_SubQuestType_descriptor(), name, value);
}
enum QuestStatus_QuestType : int {
  QuestStatus_QuestType_SERIAL = 0,
  QuestStatus_QuestType_PARALLEL = 1,
  QuestStatus_QuestType_QuestStatus_QuestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  QuestStatus_QuestType_QuestStatus_QuestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool QuestStatus_QuestType_IsValid(int value);
constexpr QuestStatus_QuestType QuestStatus_QuestType_QuestType_MIN = QuestStatus_QuestType_SERIAL;
constexpr QuestStatus_QuestType QuestStatus_QuestType_QuestType_MAX = QuestStatus_QuestType_PARALLEL;
constexpr int QuestStatus_QuestType_QuestType_ARRAYSIZE = QuestStatus_QuestType_QuestType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestStatus_QuestType_descriptor();
template<typename T>
inline const std::string& QuestStatus_QuestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestStatus_QuestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestStatus_QuestType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestStatus_QuestType_descriptor(), enum_t_value);
}
inline bool QuestStatus_QuestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestStatus_QuestType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestStatus_QuestType>(
    QuestStatus_QuestType_descriptor(), name, value);
}
enum QuestStatus_QuestProgressType : int {
  QuestStatus_QuestProgressType_UNAVAILABLE = 0,
  QuestStatus_QuestProgressType_AVAILABLE = 1,
  QuestStatus_QuestProgressType_INPROGRESS = 2,
  QuestStatus_QuestProgressType_COMPLETABLE = 3,
  QuestStatus_QuestProgressType_COMPLETED = 4,
  QuestStatus_QuestProgressType_QuestStatus_QuestProgressType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  QuestStatus_QuestProgressType_QuestStatus_QuestProgressType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool QuestStatus_QuestProgressType_IsValid(int value);
constexpr QuestStatus_QuestProgressType QuestStatus_QuestProgressType_QuestProgressType_MIN = QuestStatus_QuestProgressType_UNAVAILABLE;
constexpr QuestStatus_QuestProgressType QuestStatus_QuestProgressType_QuestProgressType_MAX = QuestStatus_QuestProgressType_COMPLETED;
constexpr int QuestStatus_QuestProgressType_QuestProgressType_ARRAYSIZE = QuestStatus_QuestProgressType_QuestProgressType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestStatus_QuestProgressType_descriptor();
template<typename T>
inline const std::string& QuestStatus_QuestProgressType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestStatus_QuestProgressType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestStatus_QuestProgressType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestStatus_QuestProgressType_descriptor(), enum_t_value);
}
inline bool QuestStatus_QuestProgressType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestStatus_QuestProgressType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestStatus_QuestProgressType>(
    QuestStatus_QuestProgressType_descriptor(), name, value);
}
enum RepBoolean_RepType : int {
  RepBoolean_RepType_RUNNING = 0,
  RepBoolean_RepType_JUMPING = 1,
  RepBoolean_RepType_EQUIPPPED = 2,
  RepBoolean_RepType_RepBoolean_RepType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RepBoolean_RepType_RepBoolean_RepType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RepBoolean_RepType_IsValid(int value);
constexpr RepBoolean_RepType RepBoolean_RepType_RepType_MIN = RepBoolean_RepType_RUNNING;
constexpr RepBoolean_RepType RepBoolean_RepType_RepType_MAX = RepBoolean_RepType_EQUIPPPED;
constexpr int RepBoolean_RepType_RepType_ARRAYSIZE = RepBoolean_RepType_RepType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RepBoolean_RepType_descriptor();
template<typename T>
inline const std::string& RepBoolean_RepType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RepBoolean_RepType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RepBoolean_RepType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RepBoolean_RepType_descriptor(), enum_t_value);
}
inline bool RepBoolean_RepType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RepBoolean_RepType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RepBoolean_RepType>(
    RepBoolean_RepType_descriptor(), name, value);
}
enum Equipment_EquipmentType : int {
  Equipment_EquipmentType_CLOTH = 0,
  Equipment_EquipmentType_WEAPON = 1,
  Equipment_EquipmentType_Equipment_EquipmentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Equipment_EquipmentType_Equipment_EquipmentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Equipment_EquipmentType_IsValid(int value);
constexpr Equipment_EquipmentType Equipment_EquipmentType_EquipmentType_MIN = Equipment_EquipmentType_CLOTH;
constexpr Equipment_EquipmentType Equipment_EquipmentType_EquipmentType_MAX = Equipment_EquipmentType_WEAPON;
constexpr int Equipment_EquipmentType_EquipmentType_ARRAYSIZE = Equipment_EquipmentType_EquipmentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Equipment_EquipmentType_descriptor();
template<typename T>
inline const std::string& Equipment_EquipmentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Equipment_EquipmentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Equipment_EquipmentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Equipment_EquipmentType_descriptor(), enum_t_value);
}
inline bool Equipment_EquipmentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Equipment_EquipmentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Equipment_EquipmentType>(
    Equipment_EquipmentType_descriptor(), name, value);
}
enum ResourceChange_ResourceType : int {
  ResourceChange_ResourceType_ENEMY = 0,
  ResourceChange_ResourceType_ITEM = 1,
  ResourceChange_ResourceType_ResourceChange_ResourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ResourceChange_ResourceType_ResourceChange_ResourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ResourceChange_ResourceType_IsValid(int value);
constexpr ResourceChange_ResourceType ResourceChange_ResourceType_ResourceType_MIN = ResourceChange_ResourceType_ENEMY;
constexpr ResourceChange_ResourceType ResourceChange_ResourceType_ResourceType_MAX = ResourceChange_ResourceType_ITEM;
constexpr int ResourceChange_ResourceType_ResourceType_ARRAYSIZE = ResourceChange_ResourceType_ResourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResourceChange_ResourceType_descriptor();
template<typename T>
inline const std::string& ResourceChange_ResourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResourceChange_ResourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResourceChange_ResourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResourceChange_ResourceType_descriptor(), enum_t_value);
}
inline bool ResourceChange_ResourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResourceChange_ResourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResourceChange_ResourceType>(
    ResourceChange_ResourceType_descriptor(), name, value);
}
enum ResourceChange_ChangeType : int {
  ResourceChange_ChangeType_REMOVE = 0,
  ResourceChange_ChangeType_SPAWN = 1,
  ResourceChange_ChangeType_ResourceChange_ChangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ResourceChange_ChangeType_ResourceChange_ChangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ResourceChange_ChangeType_IsValid(int value);
constexpr ResourceChange_ChangeType ResourceChange_ChangeType_ChangeType_MIN = ResourceChange_ChangeType_REMOVE;
constexpr ResourceChange_ChangeType ResourceChange_ChangeType_ChangeType_MAX = ResourceChange_ChangeType_SPAWN;
constexpr int ResourceChange_ChangeType_ChangeType_ARRAYSIZE = ResourceChange_ChangeType_ChangeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResourceChange_ChangeType_descriptor();
template<typename T>
inline const std::string& ResourceChange_ChangeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResourceChange_ChangeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResourceChange_ChangeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResourceChange_ChangeType_descriptor(), enum_t_value);
}
inline bool ResourceChange_ChangeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResourceChange_ChangeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResourceChange_ChangeType>(
    ResourceChange_ChangeType_descriptor(), name, value);
}
// ===================================================================

class LoginInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoObject.LoginInfo) */ {
 public:
  inline LoginInfo() : LoginInfo(nullptr) {}
  ~LoginInfo() override;
  explicit PROTOBUF_CONSTEXPR LoginInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginInfo(const LoginInfo& from);
  LoginInfo(LoginInfo&& from) noexcept
    : LoginInfo() {
    *this = ::std::move(from);
  }

  inline LoginInfo& operator=(const LoginInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginInfo& operator=(LoginInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginInfo* internal_default_instance() {
    return reinterpret_cast<const LoginInfo*>(
               &_LoginInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LoginInfo& a, LoginInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginInfo& from) {
    LoginInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoObject.LoginInfo";
  }
  protected:
  explicit LoginInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:ProtoObject.LoginInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoObject_2eproto;
};
// -------------------------------------------------------------------

class GameItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoObject.GameItem) */ {
 public:
  inline GameItem() : GameItem(nullptr) {}
  ~GameItem() override;
  explicit PROTOBUF_CONSTEXPR GameItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameItem(const GameItem& from);
  GameItem(GameItem&& from) noexcept
    : GameItem() {
    *this = ::std::move(from);
  }

  inline GameItem& operator=(const GameItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameItem& operator=(GameItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameItem* internal_default_instance() {
    return reinterpret_cast<const GameItem*>(
               &_GameItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GameItem& a, GameItem& b) {
    a.Swap(&b);
  }
  inline void Swap(GameItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameItem& from) {
    GameItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoObject.GameItem";
  }
  protected:
  explicit GameItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kNumFieldNumber = 2,
  };
  // uint64 index = 1;
  void clear_index();
  uint64_t index() const;
  void set_index(uint64_t value);
  private:
  uint64_t _internal_index() const;
  void _internal_set_index(uint64_t value);
  public:

  // uint64 num = 2;
  void clear_num();
  uint64_t num() const;
  void set_num(uint64_t value);
  private:
  uint64_t _internal_num() const;
  void _internal_set_num(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoObject.GameItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t index_;
    uint64_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoObject_2eproto;
};
// -------------------------------------------------------------------

class TypeInventory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoObject.TypeInventory) */ {
 public:
  inline TypeInventory() : TypeInventory(nullptr) {}
  ~TypeInventory() override;
  explicit PROTOBUF_CONSTEXPR TypeInventory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypeInventory(const TypeInventory& from);
  TypeInventory(TypeInventory&& from) noexcept
    : TypeInventory() {
    *this = ::std::move(from);
  }

  inline TypeInventory& operator=(const TypeInventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeInventory& operator=(TypeInventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeInventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypeInventory* internal_default_instance() {
    return reinterpret_cast<const TypeInventory*>(
               &_TypeInventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TypeInventory& a, TypeInventory& b) {
    a.Swap(&b);
  }
  inline void Swap(TypeInventory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeInventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeInventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypeInventory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TypeInventory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TypeInventory& from) {
    TypeInventory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeInventory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoObject.TypeInventory";
  }
  protected:
  explicit TypeInventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .ProtoObject.GameItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ProtoObject::GameItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::GameItem >*
      mutable_items();
  private:
  const ::ProtoObject::GameItem& _internal_items(int index) const;
  ::ProtoObject::GameItem* _internal_add_items();
  public:
  const ::ProtoObject::GameItem& items(int index) const;
  ::ProtoObject::GameItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::GameItem >&
      items() const;

  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoObject.TypeInventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::GameItem > items_;
    uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoObject_2eproto;
};
// -------------------------------------------------------------------

class Inventory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoObject.Inventory) */ {
 public:
  inline Inventory() : Inventory(nullptr) {}
  ~Inventory() override;
  explicit PROTOBUF_CONSTEXPR Inventory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Inventory(const Inventory& from);
  Inventory(Inventory&& from) noexcept
    : Inventory() {
    *this = ::std::move(from);
  }

  inline Inventory& operator=(const Inventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Inventory& operator=(Inventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Inventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const Inventory* internal_default_instance() {
    return reinterpret_cast<const Inventory*>(
               &_Inventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Inventory& a, Inventory& b) {
    a.Swap(&b);
  }
  inline void Swap(Inventory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Inventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Inventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Inventory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Inventory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Inventory& from) {
    Inventory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Inventory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoObject.Inventory";
  }
  protected:
  explicit Inventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Inventory_ItemType ItemType;
  static constexpr ItemType CLOTH =
    Inventory_ItemType_CLOTH;
  static constexpr ItemType WEAPON =
    Inventory_ItemType_WEAPON;
  static constexpr ItemType ITEM =
    Inventory_ItemType_ITEM;
  static inline bool ItemType_IsValid(int value) {
    return Inventory_ItemType_IsValid(value);
  }
  static constexpr ItemType ItemType_MIN =
    Inventory_ItemType_ItemType_MIN;
  static constexpr ItemType ItemType_MAX =
    Inventory_ItemType_ItemType_MAX;
  static constexpr int ItemType_ARRAYSIZE =
    Inventory_ItemType_ItemType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ItemType_descriptor() {
    return Inventory_ItemType_descriptor();
  }
  template<typename T>
  static inline const std::string& ItemType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ItemType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ItemType_Name.");
    return Inventory_ItemType_Name(enum_t_value);
  }
  static inline bool ItemType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ItemType* value) {
    return Inventory_ItemType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeInventoryFieldNumber = 1,
  };
  // repeated .ProtoObject.TypeInventory typeInventory = 1;
  int typeinventory_size() const;
  private:
  int _internal_typeinventory_size() const;
  public:
  void clear_typeinventory();
  ::ProtoObject::TypeInventory* mutable_typeinventory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::TypeInventory >*
      mutable_typeinventory();
  private:
  const ::ProtoObject::TypeInventory& _internal_typeinventory(int index) const;
  ::ProtoObject::TypeInventory* _internal_add_typeinventory();
  public:
  const ::ProtoObject::TypeInventory& typeinventory(int index) const;
  ::ProtoObject::TypeInventory* add_typeinventory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::TypeInventory >&
      typeinventory() const;

  // @@protoc_insertion_point(class_scope:ProtoObject.Inventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::TypeInventory > typeinventory_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoObject_2eproto;
};
// -------------------------------------------------------------------

class QuestStatus_SubQuestStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoObject.QuestStatus.SubQuestStatus) */ {
 public:
  inline QuestStatus_SubQuestStatus() : QuestStatus_SubQuestStatus(nullptr) {}
  ~QuestStatus_SubQuestStatus() override;
  explicit PROTOBUF_CONSTEXPR QuestStatus_SubQuestStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuestStatus_SubQuestStatus(const QuestStatus_SubQuestStatus& from);
  QuestStatus_SubQuestStatus(QuestStatus_SubQuestStatus&& from) noexcept
    : QuestStatus_SubQuestStatus() {
    *this = ::std::move(from);
  }

  inline QuestStatus_SubQuestStatus& operator=(const QuestStatus_SubQuestStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuestStatus_SubQuestStatus& operator=(QuestStatus_SubQuestStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuestStatus_SubQuestStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuestStatus_SubQuestStatus* internal_default_instance() {
    return reinterpret_cast<const QuestStatus_SubQuestStatus*>(
               &_QuestStatus_SubQuestStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(QuestStatus_SubQuestStatus& a, QuestStatus_SubQuestStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(QuestStatus_SubQuestStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuestStatus_SubQuestStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuestStatus_SubQuestStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuestStatus_SubQuestStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuestStatus_SubQuestStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuestStatus_SubQuestStatus& from) {
    QuestStatus_SubQuestStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuestStatus_SubQuestStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoObject.QuestStatus.SubQuestStatus";
  }
  protected:
  explicit QuestStatus_SubQuestStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef QuestStatus_SubQuestStatus_SubQuestType SubQuestType;
  static constexpr SubQuestType ARRIVAL =
    QuestStatus_SubQuestStatus_SubQuestType_ARRIVAL;
  static constexpr SubQuestType HUNT =
    QuestStatus_SubQuestStatus_SubQuestType_HUNT;
  static constexpr SubQuestType ITEM =
    QuestStatus_SubQuestStatus_SubQuestType_ITEM;
  static constexpr SubQuestType ACTION =
    QuestStatus_SubQuestStatus_SubQuestType_ACTION;
  static inline bool SubQuestType_IsValid(int value) {
    return QuestStatus_SubQuestStatus_SubQuestType_IsValid(value);
  }
  static constexpr SubQuestType SubQuestType_MIN =
    QuestStatus_SubQuestStatus_SubQuestType_SubQuestType_MIN;
  static constexpr SubQuestType SubQuestType_MAX =
    QuestStatus_SubQuestStatus_SubQuestType_SubQuestType_MAX;
  static constexpr int SubQuestType_ARRAYSIZE =
    QuestStatus_SubQuestStatus_SubQuestType_SubQuestType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SubQuestType_descriptor() {
    return QuestStatus_SubQuestStatus_SubQuestType_descriptor();
  }
  template<typename T>
  static inline const std::string& SubQuestType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SubQuestType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SubQuestType_Name.");
    return QuestStatus_SubQuestStatus_SubQuestType_Name(enum_t_value);
  }
  static inline bool SubQuestType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SubQuestType* value) {
    return QuestStatus_SubQuestStatus_SubQuestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kBStartedFieldNumber = 2,
    kBCompletedFieldNumber = 3,
    kCurrAmountFieldNumber = 4,
  };
  // .ProtoObject.QuestStatus.SubQuestStatus.SubQuestType type = 1;
  void clear_type();
  ::ProtoObject::QuestStatus_SubQuestStatus_SubQuestType type() const;
  void set_type(::ProtoObject::QuestStatus_SubQuestStatus_SubQuestType value);
  private:
  ::ProtoObject::QuestStatus_SubQuestStatus_SubQuestType _internal_type() const;
  void _internal_set_type(::ProtoObject::QuestStatus_SubQuestStatus_SubQuestType value);
  public:

  // bool bStarted = 2;
  void clear_bstarted();
  bool bstarted() const;
  void set_bstarted(bool value);
  private:
  bool _internal_bstarted() const;
  void _internal_set_bstarted(bool value);
  public:

  // bool bCompleted = 3;
  void clear_bcompleted();
  bool bcompleted() const;
  void set_bcompleted(bool value);
  private:
  bool _internal_bcompleted() const;
  void _internal_set_bcompleted(bool value);
  public:

  // uint32 currAmount = 4;
  void clear_curramount();
  uint32_t curramount() const;
  void set_curramount(uint32_t value);
  private:
  uint32_t _internal_curramount() const;
  void _internal_set_curramount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoObject.QuestStatus.SubQuestStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    bool bstarted_;
    bool bcompleted_;
    uint32_t curramount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoObject_2eproto;
};
// -------------------------------------------------------------------

class QuestStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoObject.QuestStatus) */ {
 public:
  inline QuestStatus() : QuestStatus(nullptr) {}
  ~QuestStatus() override;
  explicit PROTOBUF_CONSTEXPR QuestStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuestStatus(const QuestStatus& from);
  QuestStatus(QuestStatus&& from) noexcept
    : QuestStatus() {
    *this = ::std::move(from);
  }

  inline QuestStatus& operator=(const QuestStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuestStatus& operator=(QuestStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuestStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuestStatus* internal_default_instance() {
    return reinterpret_cast<const QuestStatus*>(
               &_QuestStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(QuestStatus& a, QuestStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(QuestStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuestStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuestStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuestStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuestStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuestStatus& from) {
    QuestStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuestStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoObject.QuestStatus";
  }
  protected:
  explicit QuestStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef QuestStatus_SubQuestStatus SubQuestStatus;

  typedef QuestStatus_QuestType QuestType;
  static constexpr QuestType SERIAL =
    QuestStatus_QuestType_SERIAL;
  static constexpr QuestType PARALLEL =
    QuestStatus_QuestType_PARALLEL;
  static inline bool QuestType_IsValid(int value) {
    return QuestStatus_QuestType_IsValid(value);
  }
  static constexpr QuestType QuestType_MIN =
    QuestStatus_QuestType_QuestType_MIN;
  static constexpr QuestType QuestType_MAX =
    QuestStatus_QuestType_QuestType_MAX;
  static constexpr int QuestType_ARRAYSIZE =
    QuestStatus_QuestType_QuestType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  QuestType_descriptor() {
    return QuestStatus_QuestType_descriptor();
  }
  template<typename T>
  static inline const std::string& QuestType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, QuestType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function QuestType_Name.");
    return QuestStatus_QuestType_Name(enum_t_value);
  }
  static inline bool QuestType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      QuestType* value) {
    return QuestStatus_QuestType_Parse(name, value);
  }

  typedef QuestStatus_QuestProgressType QuestProgressType;
  static constexpr QuestProgressType UNAVAILABLE =
    QuestStatus_QuestProgressType_UNAVAILABLE;
  static constexpr QuestProgressType AVAILABLE =
    QuestStatus_QuestProgressType_AVAILABLE;
  static constexpr QuestProgressType INPROGRESS =
    QuestStatus_QuestProgressType_INPROGRESS;
  static constexpr QuestProgressType COMPLETABLE =
    QuestStatus_QuestProgressType_COMPLETABLE;
  static constexpr QuestProgressType COMPLETED =
    QuestStatus_QuestProgressType_COMPLETED;
  static inline bool QuestProgressType_IsValid(int value) {
    return QuestStatus_QuestProgressType_IsValid(value);
  }
  static constexpr QuestProgressType QuestProgressType_MIN =
    QuestStatus_QuestProgressType_QuestProgressType_MIN;
  static constexpr QuestProgressType QuestProgressType_MAX =
    QuestStatus_QuestProgressType_QuestProgressType_MAX;
  static constexpr int QuestProgressType_ARRAYSIZE =
    QuestStatus_QuestProgressType_QuestProgressType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  QuestProgressType_descriptor() {
    return QuestStatus_QuestProgressType_descriptor();
  }
  template<typename T>
  static inline const std::string& QuestProgressType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, QuestProgressType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function QuestProgressType_Name.");
    return QuestStatus_QuestProgressType_Name(enum_t_value);
  }
  static inline bool QuestProgressType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      QuestProgressType* value) {
    return QuestStatus_QuestProgressType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSubStatusFieldNumber = 4,
    kIndexFieldNumber = 1,
    kTypeFieldNumber = 2,
    kProgressTypeFieldNumber = 3,
    kCurrPhaseFieldNumber = 5,
    kCompletedFieldNumber = 6,
  };
  // repeated .ProtoObject.QuestStatus.SubQuestStatus subStatus = 4;
  int substatus_size() const;
  private:
  int _internal_substatus_size() const;
  public:
  void clear_substatus();
  ::ProtoObject::QuestStatus_SubQuestStatus* mutable_substatus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::QuestStatus_SubQuestStatus >*
      mutable_substatus();
  private:
  const ::ProtoObject::QuestStatus_SubQuestStatus& _internal_substatus(int index) const;
  ::ProtoObject::QuestStatus_SubQuestStatus* _internal_add_substatus();
  public:
  const ::ProtoObject::QuestStatus_SubQuestStatus& substatus(int index) const;
  ::ProtoObject::QuestStatus_SubQuestStatus* add_substatus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::QuestStatus_SubQuestStatus >&
      substatus() const;

  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // .ProtoObject.QuestStatus.QuestType type = 2;
  void clear_type();
  ::ProtoObject::QuestStatus_QuestType type() const;
  void set_type(::ProtoObject::QuestStatus_QuestType value);
  private:
  ::ProtoObject::QuestStatus_QuestType _internal_type() const;
  void _internal_set_type(::ProtoObject::QuestStatus_QuestType value);
  public:

  // .ProtoObject.QuestStatus.QuestProgressType progressType = 3;
  void clear_progresstype();
  ::ProtoObject::QuestStatus_QuestProgressType progresstype() const;
  void set_progresstype(::ProtoObject::QuestStatus_QuestProgressType value);
  private:
  ::ProtoObject::QuestStatus_QuestProgressType _internal_progresstype() const;
  void _internal_set_progresstype(::ProtoObject::QuestStatus_QuestProgressType value);
  public:

  // uint32 currPhase = 5;
  void clear_currphase();
  uint32_t currphase() const;
  void set_currphase(uint32_t value);
  private:
  uint32_t _internal_currphase() const;
  void _internal_set_currphase(uint32_t value);
  public:

  // uint32 completed = 6;
  void clear_completed();
  uint32_t completed() const;
  void set_completed(uint32_t value);
  private:
  uint32_t _internal_completed() const;
  void _internal_set_completed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoObject.QuestStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::QuestStatus_SubQuestStatus > substatus_;
    uint32_t index_;
    int type_;
    int progresstype_;
    uint32_t currphase_;
    uint32_t completed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoObject_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoObject.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  explicit PROTOBUF_CONSTEXPR PlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerInfo& from) {
    PlayerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoObject.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestStatusFieldNumber = 9,
    kNameFieldNumber = 1,
    kInventoryFieldNumber = 8,
    kLevelFieldNumber = 2,
    kMapFieldNumber = 3,
    kLocXFieldNumber = 4,
    kLocYFieldNumber = 5,
    kGoldFieldNumber = 7,
    kUserIdxFieldNumber = 10,
    kLocZFieldNumber = 6,
  };
  // repeated .ProtoObject.QuestStatus questStatus = 9;
  int queststatus_size() const;
  private:
  int _internal_queststatus_size() const;
  public:
  void clear_queststatus();
  ::ProtoObject::QuestStatus* mutable_queststatus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::QuestStatus >*
      mutable_queststatus();
  private:
  const ::ProtoObject::QuestStatus& _internal_queststatus(int index) const;
  ::ProtoObject::QuestStatus* _internal_add_queststatus();
  public:
  const ::ProtoObject::QuestStatus& queststatus(int index) const;
  ::ProtoObject::QuestStatus* add_queststatus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::QuestStatus >&
      queststatus() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ProtoObject.Inventory inventory = 8;
  bool has_inventory() const;
  private:
  bool _internal_has_inventory() const;
  public:
  void clear_inventory();
  const ::ProtoObject::Inventory& inventory() const;
  PROTOBUF_NODISCARD ::ProtoObject::Inventory* release_inventory();
  ::ProtoObject::Inventory* mutable_inventory();
  void set_allocated_inventory(::ProtoObject::Inventory* inventory);
  private:
  const ::ProtoObject::Inventory& _internal_inventory() const;
  ::ProtoObject::Inventory* _internal_mutable_inventory();
  public:
  void unsafe_arena_set_allocated_inventory(
      ::ProtoObject::Inventory* inventory);
  ::ProtoObject::Inventory* unsafe_arena_release_inventory();

  // uint32 level = 2;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // uint32 map = 3;
  void clear_map();
  uint32_t map() const;
  void set_map(uint32_t value);
  private:
  uint32_t _internal_map() const;
  void _internal_set_map(uint32_t value);
  public:

  // float loc_x = 4;
  void clear_loc_x();
  float loc_x() const;
  void set_loc_x(float value);
  private:
  float _internal_loc_x() const;
  void _internal_set_loc_x(float value);
  public:

  // float loc_y = 5;
  void clear_loc_y();
  float loc_y() const;
  void set_loc_y(float value);
  private:
  float _internal_loc_y() const;
  void _internal_set_loc_y(float value);
  public:

  // uint64 gold = 7;
  void clear_gold();
  uint64_t gold() const;
  void set_gold(uint64_t value);
  private:
  uint64_t _internal_gold() const;
  void _internal_set_gold(uint64_t value);
  public:

  // uint64 userIdx = 10;
  void clear_useridx();
  uint64_t useridx() const;
  void set_useridx(uint64_t value);
  private:
  uint64_t _internal_useridx() const;
  void _internal_set_useridx(uint64_t value);
  public:

  // float loc_z = 6;
  void clear_loc_z();
  float loc_z() const;
  void set_loc_z(float value);
  private:
  float _internal_loc_z() const;
  void _internal_set_loc_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoObject.PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::QuestStatus > queststatus_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::ProtoObject::Inventory* inventory_;
    uint32_t level_;
    uint32_t map_;
    float loc_x_;
    float loc_y_;
    uint64_t gold_;
    uint64_t useridx_;
    float loc_z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoObject_2eproto;
};
// -------------------------------------------------------------------

class Nickname final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoObject.Nickname) */ {
 public:
  inline Nickname() : Nickname(nullptr) {}
  ~Nickname() override;
  explicit PROTOBUF_CONSTEXPR Nickname(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Nickname(const Nickname& from);
  Nickname(Nickname&& from) noexcept
    : Nickname() {
    *this = ::std::move(from);
  }

  inline Nickname& operator=(const Nickname& from) {
    CopyFrom(from);
    return *this;
  }
  inline Nickname& operator=(Nickname&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Nickname& default_instance() {
    return *internal_default_instance();
  }
  static inline const Nickname* internal_default_instance() {
    return reinterpret_cast<const Nickname*>(
               &_Nickname_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Nickname& a, Nickname& b) {
    a.Swap(&b);
  }
  inline void Swap(Nickname* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Nickname* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Nickname* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Nickname>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Nickname& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Nickname& from) {
    Nickname::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Nickname* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoObject.Nickname";
  }
  protected:
  explicit Nickname(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 1,
  };
  // string nickname = 1;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // @@protoc_insertion_point(class_scope:ProtoObject.Nickname)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoObject_2eproto;
};
// -------------------------------------------------------------------

class Location final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoObject.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  explicit PROTOBUF_CONSTEXPR Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Location& from) {
    Location::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoObject.Location";
  }
  protected:
  explicit Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdxFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
    kPitchFieldNumber = 5,
    kYawFieldNumber = 6,
  };
  // uint64 userIdx = 1;
  void clear_useridx();
  uint64_t useridx() const;
  void set_useridx(uint64_t value);
  private:
  uint64_t _internal_useridx() const;
  void _internal_set_useridx(uint64_t value);
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 4;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float pitch = 5;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float yaw = 6;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoObject.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t useridx_;
    float x_;
    float y_;
    float z_;
    float pitch_;
    float yaw_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoObject_2eproto;
};
// -------------------------------------------------------------------

class RepBoolean final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoObject.RepBoolean) */ {
 public:
  inline RepBoolean() : RepBoolean(nullptr) {}
  ~RepBoolean() override;
  explicit PROTOBUF_CONSTEXPR RepBoolean(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RepBoolean(const RepBoolean& from);
  RepBoolean(RepBoolean&& from) noexcept
    : RepBoolean() {
    *this = ::std::move(from);
  }

  inline RepBoolean& operator=(const RepBoolean& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepBoolean& operator=(RepBoolean&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepBoolean& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepBoolean* internal_default_instance() {
    return reinterpret_cast<const RepBoolean*>(
               &_RepBoolean_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RepBoolean& a, RepBoolean& b) {
    a.Swap(&b);
  }
  inline void Swap(RepBoolean* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepBoolean* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepBoolean* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepBoolean>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RepBoolean& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RepBoolean& from) {
    RepBoolean::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepBoolean* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoObject.RepBoolean";
  }
  protected:
  explicit RepBoolean(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RepBoolean_RepType RepType;
  static constexpr RepType RUNNING =
    RepBoolean_RepType_RUNNING;
  static constexpr RepType JUMPING =
    RepBoolean_RepType_JUMPING;
  static constexpr RepType EQUIPPPED =
    RepBoolean_RepType_EQUIPPPED;
  static inline bool RepType_IsValid(int value) {
    return RepBoolean_RepType_IsValid(value);
  }
  static constexpr RepType RepType_MIN =
    RepBoolean_RepType_RepType_MIN;
  static constexpr RepType RepType_MAX =
    RepBoolean_RepType_RepType_MAX;
  static constexpr int RepType_ARRAYSIZE =
    RepBoolean_RepType_RepType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RepType_descriptor() {
    return RepBoolean_RepType_descriptor();
  }
  template<typename T>
  static inline const std::string& RepType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RepType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RepType_Name.");
    return RepBoolean_RepType_Name(enum_t_value);
  }
  static inline bool RepType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RepType* value) {
    return RepBoolean_RepType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdxFieldNumber = 1,
    kTypeFieldNumber = 2,
    kBooleanFieldNumber = 3,
  };
  // uint64 userIdx = 1;
  void clear_useridx();
  uint64_t useridx() const;
  void set_useridx(uint64_t value);
  private:
  uint64_t _internal_useridx() const;
  void _internal_set_useridx(uint64_t value);
  public:

  // .ProtoObject.RepBoolean.RepType type = 2;
  void clear_type();
  ::ProtoObject::RepBoolean_RepType type() const;
  void set_type(::ProtoObject::RepBoolean_RepType value);
  private:
  ::ProtoObject::RepBoolean_RepType _internal_type() const;
  void _internal_set_type(::ProtoObject::RepBoolean_RepType value);
  public:

  // bool boolean = 3;
  void clear_boolean();
  bool boolean() const;
  void set_boolean(bool value);
  private:
  bool _internal_boolean() const;
  void _internal_set_boolean(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoObject.RepBoolean)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t useridx_;
    int type_;
    bool boolean_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoObject_2eproto;
};
// -------------------------------------------------------------------

class Equipment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoObject.Equipment) */ {
 public:
  inline Equipment() : Equipment(nullptr) {}
  ~Equipment() override;
  explicit PROTOBUF_CONSTEXPR Equipment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Equipment(const Equipment& from);
  Equipment(Equipment&& from) noexcept
    : Equipment() {
    *this = ::std::move(from);
  }

  inline Equipment& operator=(const Equipment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Equipment& operator=(Equipment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Equipment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Equipment* internal_default_instance() {
    return reinterpret_cast<const Equipment*>(
               &_Equipment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Equipment& a, Equipment& b) {
    a.Swap(&b);
  }
  inline void Swap(Equipment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Equipment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Equipment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Equipment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Equipment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Equipment& from) {
    Equipment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Equipment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoObject.Equipment";
  }
  protected:
  explicit Equipment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Equipment_EquipmentType EquipmentType;
  static constexpr EquipmentType CLOTH =
    Equipment_EquipmentType_CLOTH;
  static constexpr EquipmentType WEAPON =
    Equipment_EquipmentType_WEAPON;
  static inline bool EquipmentType_IsValid(int value) {
    return Equipment_EquipmentType_IsValid(value);
  }
  static constexpr EquipmentType EquipmentType_MIN =
    Equipment_EquipmentType_EquipmentType_MIN;
  static constexpr EquipmentType EquipmentType_MAX =
    Equipment_EquipmentType_EquipmentType_MAX;
  static constexpr int EquipmentType_ARRAYSIZE =
    Equipment_EquipmentType_EquipmentType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EquipmentType_descriptor() {
    return Equipment_EquipmentType_descriptor();
  }
  template<typename T>
  static inline const std::string& EquipmentType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EquipmentType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EquipmentType_Name.");
    return Equipment_EquipmentType_Name(enum_t_value);
  }
  static inline bool EquipmentType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EquipmentType* value) {
    return Equipment_EquipmentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdxFieldNumber = 1,
    kItemIndexFieldNumber = 3,
    kEquipTypeFieldNumber = 2,
  };
  // uint64 userIdx = 1;
  void clear_useridx();
  uint64_t useridx() const;
  void set_useridx(uint64_t value);
  private:
  uint64_t _internal_useridx() const;
  void _internal_set_useridx(uint64_t value);
  public:

  // uint64 itemIndex = 3;
  void clear_itemindex();
  uint64_t itemindex() const;
  void set_itemindex(uint64_t value);
  private:
  uint64_t _internal_itemindex() const;
  void _internal_set_itemindex(uint64_t value);
  public:

  // .ProtoObject.Equipment.EquipmentType equipType = 2;
  void clear_equiptype();
  ::ProtoObject::Equipment_EquipmentType equiptype() const;
  void set_equiptype(::ProtoObject::Equipment_EquipmentType value);
  private:
  ::ProtoObject::Equipment_EquipmentType _internal_equiptype() const;
  void _internal_set_equiptype(::ProtoObject::Equipment_EquipmentType value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoObject.Equipment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t useridx_;
    uint64_t itemindex_;
    int equiptype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoObject_2eproto;
};
// -------------------------------------------------------------------

class ResourceChange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoObject.ResourceChange) */ {
 public:
  inline ResourceChange() : ResourceChange(nullptr) {}
  ~ResourceChange() override;
  explicit PROTOBUF_CONSTEXPR ResourceChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceChange(const ResourceChange& from);
  ResourceChange(ResourceChange&& from) noexcept
    : ResourceChange() {
    *this = ::std::move(from);
  }

  inline ResourceChange& operator=(const ResourceChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceChange& operator=(ResourceChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceChange* internal_default_instance() {
    return reinterpret_cast<const ResourceChange*>(
               &_ResourceChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ResourceChange& a, ResourceChange& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceChange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceChange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourceChange& from) {
    ResourceChange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceChange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoObject.ResourceChange";
  }
  protected:
  explicit ResourceChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResourceChange_ResourceType ResourceType;
  static constexpr ResourceType ENEMY =
    ResourceChange_ResourceType_ENEMY;
  static constexpr ResourceType ITEM =
    ResourceChange_ResourceType_ITEM;
  static inline bool ResourceType_IsValid(int value) {
    return ResourceChange_ResourceType_IsValid(value);
  }
  static constexpr ResourceType ResourceType_MIN =
    ResourceChange_ResourceType_ResourceType_MIN;
  static constexpr ResourceType ResourceType_MAX =
    ResourceChange_ResourceType_ResourceType_MAX;
  static constexpr int ResourceType_ARRAYSIZE =
    ResourceChange_ResourceType_ResourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ResourceType_descriptor() {
    return ResourceChange_ResourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& ResourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResourceType_Name.");
    return ResourceChange_ResourceType_Name(enum_t_value);
  }
  static inline bool ResourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResourceType* value) {
    return ResourceChange_ResourceType_Parse(name, value);
  }

  typedef ResourceChange_ChangeType ChangeType;
  static constexpr ChangeType REMOVE =
    ResourceChange_ChangeType_REMOVE;
  static constexpr ChangeType SPAWN =
    ResourceChange_ChangeType_SPAWN;
  static inline bool ChangeType_IsValid(int value) {
    return ResourceChange_ChangeType_IsValid(value);
  }
  static constexpr ChangeType ChangeType_MIN =
    ResourceChange_ChangeType_ChangeType_MIN;
  static constexpr ChangeType ChangeType_MAX =
    ResourceChange_ChangeType_ChangeType_MAX;
  static constexpr int ChangeType_ARRAYSIZE =
    ResourceChange_ChangeType_ChangeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ChangeType_descriptor() {
    return ResourceChange_ChangeType_descriptor();
  }
  template<typename T>
  static inline const std::string& ChangeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ChangeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ChangeType_Name.");
    return ResourceChange_ChangeType_Name(enum_t_value);
  }
  static inline bool ChangeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ChangeType* value) {
    return ResourceChange_ChangeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMapIdxFieldNumber = 1,
    kResTypeFieldNumber = 2,
    kResIdxFieldNumber = 4,
    kResChangeTypeFieldNumber = 3,
  };
  // uint32 mapIdx = 1;
  void clear_mapidx();
  uint32_t mapidx() const;
  void set_mapidx(uint32_t value);
  private:
  uint32_t _internal_mapidx() const;
  void _internal_set_mapidx(uint32_t value);
  public:

  // .ProtoObject.ResourceChange.ResourceType resType = 2;
  void clear_restype();
  ::ProtoObject::ResourceChange_ResourceType restype() const;
  void set_restype(::ProtoObject::ResourceChange_ResourceType value);
  private:
  ::ProtoObject::ResourceChange_ResourceType _internal_restype() const;
  void _internal_set_restype(::ProtoObject::ResourceChange_ResourceType value);
  public:

  // uint64 resIdx = 4;
  void clear_residx();
  uint64_t residx() const;
  void set_residx(uint64_t value);
  private:
  uint64_t _internal_residx() const;
  void _internal_set_residx(uint64_t value);
  public:

  // .ProtoObject.ResourceChange.ChangeType resChangeType = 3;
  void clear_reschangetype();
  ::ProtoObject::ResourceChange_ChangeType reschangetype() const;
  void set_reschangetype(::ProtoObject::ResourceChange_ChangeType value);
  private:
  ::ProtoObject::ResourceChange_ChangeType _internal_reschangetype() const;
  void _internal_set_reschangetype(::ProtoObject::ResourceChange_ChangeType value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoObject.ResourceChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t mapidx_;
    int restype_;
    uint64_t residx_;
    int reschangetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoObject_2eproto;
};
// -------------------------------------------------------------------

class MapTransition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoObject.MapTransition) */ {
 public:
  inline MapTransition() : MapTransition(nullptr) {}
  ~MapTransition() override;
  explicit PROTOBUF_CONSTEXPR MapTransition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapTransition(const MapTransition& from);
  MapTransition(MapTransition&& from) noexcept
    : MapTransition() {
    *this = ::std::move(from);
  }

  inline MapTransition& operator=(const MapTransition& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapTransition& operator=(MapTransition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapTransition& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapTransition* internal_default_instance() {
    return reinterpret_cast<const MapTransition*>(
               &_MapTransition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MapTransition& a, MapTransition& b) {
    a.Swap(&b);
  }
  inline void Swap(MapTransition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapTransition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapTransition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapTransition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapTransition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MapTransition& from) {
    MapTransition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapTransition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoObject.MapTransition";
  }
  protected:
  explicit MapTransition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdxFieldNumber = 1,
    kBeforeFieldNumber = 2,
    kAfterFieldNumber = 3,
  };
  // uint64 userIdx = 1;
  void clear_useridx();
  uint64_t useridx() const;
  void set_useridx(uint64_t value);
  private:
  uint64_t _internal_useridx() const;
  void _internal_set_useridx(uint64_t value);
  public:

  // uint32 before = 2;
  void clear_before();
  uint32_t before() const;
  void set_before(uint32_t value);
  private:
  uint32_t _internal_before() const;
  void _internal_set_before(uint32_t value);
  public:

  // uint32 after = 3;
  void clear_after();
  uint32_t after() const;
  void set_after(uint32_t value);
  private:
  uint32_t _internal_after() const;
  void _internal_set_after(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoObject.MapTransition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t useridx_;
    uint32_t before_;
    uint32_t after_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoObject_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoginInfo

// string id = 1;
inline void LoginInfo::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& LoginInfo::id() const {
  // @@protoc_insertion_point(field_get:ProtoObject.LoginInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginInfo::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoObject.LoginInfo.id)
}
inline std::string* LoginInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ProtoObject.LoginInfo.id)
  return _s;
}
inline const std::string& LoginInfo::_internal_id() const {
  return _impl_.id_.Get();
}
inline void LoginInfo::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginInfo::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginInfo::release_id() {
  // @@protoc_insertion_point(field_release:ProtoObject.LoginInfo.id)
  return _impl_.id_.Release();
}
inline void LoginInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoObject.LoginInfo.id)
}

// string password = 2;
inline void LoginInfo::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginInfo::password() const {
  // @@protoc_insertion_point(field_get:ProtoObject.LoginInfo.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginInfo::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoObject.LoginInfo.password)
}
inline std::string* LoginInfo::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:ProtoObject.LoginInfo.password)
  return _s;
}
inline const std::string& LoginInfo::_internal_password() const {
  return _impl_.password_.Get();
}
inline void LoginInfo::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginInfo::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginInfo::release_password() {
  // @@protoc_insertion_point(field_release:ProtoObject.LoginInfo.password)
  return _impl_.password_.Release();
}
inline void LoginInfo::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoObject.LoginInfo.password)
}

// -------------------------------------------------------------------

// GameItem

// uint64 index = 1;
inline void GameItem::clear_index() {
  _impl_.index_ = uint64_t{0u};
}
inline uint64_t GameItem::_internal_index() const {
  return _impl_.index_;
}
inline uint64_t GameItem::index() const {
  // @@protoc_insertion_point(field_get:ProtoObject.GameItem.index)
  return _internal_index();
}
inline void GameItem::_internal_set_index(uint64_t value) {
  
  _impl_.index_ = value;
}
inline void GameItem::set_index(uint64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:ProtoObject.GameItem.index)
}

// uint64 num = 2;
inline void GameItem::clear_num() {
  _impl_.num_ = uint64_t{0u};
}
inline uint64_t GameItem::_internal_num() const {
  return _impl_.num_;
}
inline uint64_t GameItem::num() const {
  // @@protoc_insertion_point(field_get:ProtoObject.GameItem.num)
  return _internal_num();
}
inline void GameItem::_internal_set_num(uint64_t value) {
  
  _impl_.num_ = value;
}
inline void GameItem::set_num(uint64_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:ProtoObject.GameItem.num)
}

// -------------------------------------------------------------------

// TypeInventory

// uint32 type = 1;
inline void TypeInventory::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t TypeInventory::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t TypeInventory::type() const {
  // @@protoc_insertion_point(field_get:ProtoObject.TypeInventory.type)
  return _internal_type();
}
inline void TypeInventory::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void TypeInventory::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ProtoObject.TypeInventory.type)
}

// repeated .ProtoObject.GameItem items = 2;
inline int TypeInventory::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int TypeInventory::items_size() const {
  return _internal_items_size();
}
inline void TypeInventory::clear_items() {
  _impl_.items_.Clear();
}
inline ::ProtoObject::GameItem* TypeInventory::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ProtoObject.TypeInventory.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::GameItem >*
TypeInventory::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ProtoObject.TypeInventory.items)
  return &_impl_.items_;
}
inline const ::ProtoObject::GameItem& TypeInventory::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::ProtoObject::GameItem& TypeInventory::items(int index) const {
  // @@protoc_insertion_point(field_get:ProtoObject.TypeInventory.items)
  return _internal_items(index);
}
inline ::ProtoObject::GameItem* TypeInventory::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::ProtoObject::GameItem* TypeInventory::add_items() {
  ::ProtoObject::GameItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ProtoObject.TypeInventory.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::GameItem >&
TypeInventory::items() const {
  // @@protoc_insertion_point(field_list:ProtoObject.TypeInventory.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// Inventory

// repeated .ProtoObject.TypeInventory typeInventory = 1;
inline int Inventory::_internal_typeinventory_size() const {
  return _impl_.typeinventory_.size();
}
inline int Inventory::typeinventory_size() const {
  return _internal_typeinventory_size();
}
inline void Inventory::clear_typeinventory() {
  _impl_.typeinventory_.Clear();
}
inline ::ProtoObject::TypeInventory* Inventory::mutable_typeinventory(int index) {
  // @@protoc_insertion_point(field_mutable:ProtoObject.Inventory.typeInventory)
  return _impl_.typeinventory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::TypeInventory >*
Inventory::mutable_typeinventory() {
  // @@protoc_insertion_point(field_mutable_list:ProtoObject.Inventory.typeInventory)
  return &_impl_.typeinventory_;
}
inline const ::ProtoObject::TypeInventory& Inventory::_internal_typeinventory(int index) const {
  return _impl_.typeinventory_.Get(index);
}
inline const ::ProtoObject::TypeInventory& Inventory::typeinventory(int index) const {
  // @@protoc_insertion_point(field_get:ProtoObject.Inventory.typeInventory)
  return _internal_typeinventory(index);
}
inline ::ProtoObject::TypeInventory* Inventory::_internal_add_typeinventory() {
  return _impl_.typeinventory_.Add();
}
inline ::ProtoObject::TypeInventory* Inventory::add_typeinventory() {
  ::ProtoObject::TypeInventory* _add = _internal_add_typeinventory();
  // @@protoc_insertion_point(field_add:ProtoObject.Inventory.typeInventory)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::TypeInventory >&
Inventory::typeinventory() const {
  // @@protoc_insertion_point(field_list:ProtoObject.Inventory.typeInventory)
  return _impl_.typeinventory_;
}

// -------------------------------------------------------------------

// QuestStatus_SubQuestStatus

// .ProtoObject.QuestStatus.SubQuestStatus.SubQuestType type = 1;
inline void QuestStatus_SubQuestStatus::clear_type() {
  _impl_.type_ = 0;
}
inline ::ProtoObject::QuestStatus_SubQuestStatus_SubQuestType QuestStatus_SubQuestStatus::_internal_type() const {
  return static_cast< ::ProtoObject::QuestStatus_SubQuestStatus_SubQuestType >(_impl_.type_);
}
inline ::ProtoObject::QuestStatus_SubQuestStatus_SubQuestType QuestStatus_SubQuestStatus::type() const {
  // @@protoc_insertion_point(field_get:ProtoObject.QuestStatus.SubQuestStatus.type)
  return _internal_type();
}
inline void QuestStatus_SubQuestStatus::_internal_set_type(::ProtoObject::QuestStatus_SubQuestStatus_SubQuestType value) {
  
  _impl_.type_ = value;
}
inline void QuestStatus_SubQuestStatus::set_type(::ProtoObject::QuestStatus_SubQuestStatus_SubQuestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ProtoObject.QuestStatus.SubQuestStatus.type)
}

// bool bStarted = 2;
inline void QuestStatus_SubQuestStatus::clear_bstarted() {
  _impl_.bstarted_ = false;
}
inline bool QuestStatus_SubQuestStatus::_internal_bstarted() const {
  return _impl_.bstarted_;
}
inline bool QuestStatus_SubQuestStatus::bstarted() const {
  // @@protoc_insertion_point(field_get:ProtoObject.QuestStatus.SubQuestStatus.bStarted)
  return _internal_bstarted();
}
inline void QuestStatus_SubQuestStatus::_internal_set_bstarted(bool value) {
  
  _impl_.bstarted_ = value;
}
inline void QuestStatus_SubQuestStatus::set_bstarted(bool value) {
  _internal_set_bstarted(value);
  // @@protoc_insertion_point(field_set:ProtoObject.QuestStatus.SubQuestStatus.bStarted)
}

// bool bCompleted = 3;
inline void QuestStatus_SubQuestStatus::clear_bcompleted() {
  _impl_.bcompleted_ = false;
}
inline bool QuestStatus_SubQuestStatus::_internal_bcompleted() const {
  return _impl_.bcompleted_;
}
inline bool QuestStatus_SubQuestStatus::bcompleted() const {
  // @@protoc_insertion_point(field_get:ProtoObject.QuestStatus.SubQuestStatus.bCompleted)
  return _internal_bcompleted();
}
inline void QuestStatus_SubQuestStatus::_internal_set_bcompleted(bool value) {
  
  _impl_.bcompleted_ = value;
}
inline void QuestStatus_SubQuestStatus::set_bcompleted(bool value) {
  _internal_set_bcompleted(value);
  // @@protoc_insertion_point(field_set:ProtoObject.QuestStatus.SubQuestStatus.bCompleted)
}

// uint32 currAmount = 4;
inline void QuestStatus_SubQuestStatus::clear_curramount() {
  _impl_.curramount_ = 0u;
}
inline uint32_t QuestStatus_SubQuestStatus::_internal_curramount() const {
  return _impl_.curramount_;
}
inline uint32_t QuestStatus_SubQuestStatus::curramount() const {
  // @@protoc_insertion_point(field_get:ProtoObject.QuestStatus.SubQuestStatus.currAmount)
  return _internal_curramount();
}
inline void QuestStatus_SubQuestStatus::_internal_set_curramount(uint32_t value) {
  
  _impl_.curramount_ = value;
}
inline void QuestStatus_SubQuestStatus::set_curramount(uint32_t value) {
  _internal_set_curramount(value);
  // @@protoc_insertion_point(field_set:ProtoObject.QuestStatus.SubQuestStatus.currAmount)
}

// -------------------------------------------------------------------

// QuestStatus

// uint32 index = 1;
inline void QuestStatus::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t QuestStatus::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t QuestStatus::index() const {
  // @@protoc_insertion_point(field_get:ProtoObject.QuestStatus.index)
  return _internal_index();
}
inline void QuestStatus::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void QuestStatus::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:ProtoObject.QuestStatus.index)
}

// .ProtoObject.QuestStatus.QuestType type = 2;
inline void QuestStatus::clear_type() {
  _impl_.type_ = 0;
}
inline ::ProtoObject::QuestStatus_QuestType QuestStatus::_internal_type() const {
  return static_cast< ::ProtoObject::QuestStatus_QuestType >(_impl_.type_);
}
inline ::ProtoObject::QuestStatus_QuestType QuestStatus::type() const {
  // @@protoc_insertion_point(field_get:ProtoObject.QuestStatus.type)
  return _internal_type();
}
inline void QuestStatus::_internal_set_type(::ProtoObject::QuestStatus_QuestType value) {
  
  _impl_.type_ = value;
}
inline void QuestStatus::set_type(::ProtoObject::QuestStatus_QuestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ProtoObject.QuestStatus.type)
}

// .ProtoObject.QuestStatus.QuestProgressType progressType = 3;
inline void QuestStatus::clear_progresstype() {
  _impl_.progresstype_ = 0;
}
inline ::ProtoObject::QuestStatus_QuestProgressType QuestStatus::_internal_progresstype() const {
  return static_cast< ::ProtoObject::QuestStatus_QuestProgressType >(_impl_.progresstype_);
}
inline ::ProtoObject::QuestStatus_QuestProgressType QuestStatus::progresstype() const {
  // @@protoc_insertion_point(field_get:ProtoObject.QuestStatus.progressType)
  return _internal_progresstype();
}
inline void QuestStatus::_internal_set_progresstype(::ProtoObject::QuestStatus_QuestProgressType value) {
  
  _impl_.progresstype_ = value;
}
inline void QuestStatus::set_progresstype(::ProtoObject::QuestStatus_QuestProgressType value) {
  _internal_set_progresstype(value);
  // @@protoc_insertion_point(field_set:ProtoObject.QuestStatus.progressType)
}

// repeated .ProtoObject.QuestStatus.SubQuestStatus subStatus = 4;
inline int QuestStatus::_internal_substatus_size() const {
  return _impl_.substatus_.size();
}
inline int QuestStatus::substatus_size() const {
  return _internal_substatus_size();
}
inline void QuestStatus::clear_substatus() {
  _impl_.substatus_.Clear();
}
inline ::ProtoObject::QuestStatus_SubQuestStatus* QuestStatus::mutable_substatus(int index) {
  // @@protoc_insertion_point(field_mutable:ProtoObject.QuestStatus.subStatus)
  return _impl_.substatus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::QuestStatus_SubQuestStatus >*
QuestStatus::mutable_substatus() {
  // @@protoc_insertion_point(field_mutable_list:ProtoObject.QuestStatus.subStatus)
  return &_impl_.substatus_;
}
inline const ::ProtoObject::QuestStatus_SubQuestStatus& QuestStatus::_internal_substatus(int index) const {
  return _impl_.substatus_.Get(index);
}
inline const ::ProtoObject::QuestStatus_SubQuestStatus& QuestStatus::substatus(int index) const {
  // @@protoc_insertion_point(field_get:ProtoObject.QuestStatus.subStatus)
  return _internal_substatus(index);
}
inline ::ProtoObject::QuestStatus_SubQuestStatus* QuestStatus::_internal_add_substatus() {
  return _impl_.substatus_.Add();
}
inline ::ProtoObject::QuestStatus_SubQuestStatus* QuestStatus::add_substatus() {
  ::ProtoObject::QuestStatus_SubQuestStatus* _add = _internal_add_substatus();
  // @@protoc_insertion_point(field_add:ProtoObject.QuestStatus.subStatus)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::QuestStatus_SubQuestStatus >&
QuestStatus::substatus() const {
  // @@protoc_insertion_point(field_list:ProtoObject.QuestStatus.subStatus)
  return _impl_.substatus_;
}

// uint32 currPhase = 5;
inline void QuestStatus::clear_currphase() {
  _impl_.currphase_ = 0u;
}
inline uint32_t QuestStatus::_internal_currphase() const {
  return _impl_.currphase_;
}
inline uint32_t QuestStatus::currphase() const {
  // @@protoc_insertion_point(field_get:ProtoObject.QuestStatus.currPhase)
  return _internal_currphase();
}
inline void QuestStatus::_internal_set_currphase(uint32_t value) {
  
  _impl_.currphase_ = value;
}
inline void QuestStatus::set_currphase(uint32_t value) {
  _internal_set_currphase(value);
  // @@protoc_insertion_point(field_set:ProtoObject.QuestStatus.currPhase)
}

// uint32 completed = 6;
inline void QuestStatus::clear_completed() {
  _impl_.completed_ = 0u;
}
inline uint32_t QuestStatus::_internal_completed() const {
  return _impl_.completed_;
}
inline uint32_t QuestStatus::completed() const {
  // @@protoc_insertion_point(field_get:ProtoObject.QuestStatus.completed)
  return _internal_completed();
}
inline void QuestStatus::_internal_set_completed(uint32_t value) {
  
  _impl_.completed_ = value;
}
inline void QuestStatus::set_completed(uint32_t value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:ProtoObject.QuestStatus.completed)
}

// -------------------------------------------------------------------

// PlayerInfo

// string name = 1;
inline void PlayerInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:ProtoObject.PlayerInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoObject.PlayerInfo.name)
}
inline std::string* PlayerInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ProtoObject.PlayerInfo.name)
  return _s;
}
inline const std::string& PlayerInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PlayerInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_name() {
  // @@protoc_insertion_point(field_release:ProtoObject.PlayerInfo.name)
  return _impl_.name_.Release();
}
inline void PlayerInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoObject.PlayerInfo.name)
}

// uint32 level = 2;
inline void PlayerInfo::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t PlayerInfo::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t PlayerInfo::level() const {
  // @@protoc_insertion_point(field_get:ProtoObject.PlayerInfo.level)
  return _internal_level();
}
inline void PlayerInfo::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void PlayerInfo::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:ProtoObject.PlayerInfo.level)
}

// uint32 map = 3;
inline void PlayerInfo::clear_map() {
  _impl_.map_ = 0u;
}
inline uint32_t PlayerInfo::_internal_map() const {
  return _impl_.map_;
}
inline uint32_t PlayerInfo::map() const {
  // @@protoc_insertion_point(field_get:ProtoObject.PlayerInfo.map)
  return _internal_map();
}
inline void PlayerInfo::_internal_set_map(uint32_t value) {
  
  _impl_.map_ = value;
}
inline void PlayerInfo::set_map(uint32_t value) {
  _internal_set_map(value);
  // @@protoc_insertion_point(field_set:ProtoObject.PlayerInfo.map)
}

// float loc_x = 4;
inline void PlayerInfo::clear_loc_x() {
  _impl_.loc_x_ = 0;
}
inline float PlayerInfo::_internal_loc_x() const {
  return _impl_.loc_x_;
}
inline float PlayerInfo::loc_x() const {
  // @@protoc_insertion_point(field_get:ProtoObject.PlayerInfo.loc_x)
  return _internal_loc_x();
}
inline void PlayerInfo::_internal_set_loc_x(float value) {
  
  _impl_.loc_x_ = value;
}
inline void PlayerInfo::set_loc_x(float value) {
  _internal_set_loc_x(value);
  // @@protoc_insertion_point(field_set:ProtoObject.PlayerInfo.loc_x)
}

// float loc_y = 5;
inline void PlayerInfo::clear_loc_y() {
  _impl_.loc_y_ = 0;
}
inline float PlayerInfo::_internal_loc_y() const {
  return _impl_.loc_y_;
}
inline float PlayerInfo::loc_y() const {
  // @@protoc_insertion_point(field_get:ProtoObject.PlayerInfo.loc_y)
  return _internal_loc_y();
}
inline void PlayerInfo::_internal_set_loc_y(float value) {
  
  _impl_.loc_y_ = value;
}
inline void PlayerInfo::set_loc_y(float value) {
  _internal_set_loc_y(value);
  // @@protoc_insertion_point(field_set:ProtoObject.PlayerInfo.loc_y)
}

// float loc_z = 6;
inline void PlayerInfo::clear_loc_z() {
  _impl_.loc_z_ = 0;
}
inline float PlayerInfo::_internal_loc_z() const {
  return _impl_.loc_z_;
}
inline float PlayerInfo::loc_z() const {
  // @@protoc_insertion_point(field_get:ProtoObject.PlayerInfo.loc_z)
  return _internal_loc_z();
}
inline void PlayerInfo::_internal_set_loc_z(float value) {
  
  _impl_.loc_z_ = value;
}
inline void PlayerInfo::set_loc_z(float value) {
  _internal_set_loc_z(value);
  // @@protoc_insertion_point(field_set:ProtoObject.PlayerInfo.loc_z)
}

// uint64 gold = 7;
inline void PlayerInfo::clear_gold() {
  _impl_.gold_ = uint64_t{0u};
}
inline uint64_t PlayerInfo::_internal_gold() const {
  return _impl_.gold_;
}
inline uint64_t PlayerInfo::gold() const {
  // @@protoc_insertion_point(field_get:ProtoObject.PlayerInfo.gold)
  return _internal_gold();
}
inline void PlayerInfo::_internal_set_gold(uint64_t value) {
  
  _impl_.gold_ = value;
}
inline void PlayerInfo::set_gold(uint64_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:ProtoObject.PlayerInfo.gold)
}

// .ProtoObject.Inventory inventory = 8;
inline bool PlayerInfo::_internal_has_inventory() const {
  return this != internal_default_instance() && _impl_.inventory_ != nullptr;
}
inline bool PlayerInfo::has_inventory() const {
  return _internal_has_inventory();
}
inline void PlayerInfo::clear_inventory() {
  if (GetArenaForAllocation() == nullptr && _impl_.inventory_ != nullptr) {
    delete _impl_.inventory_;
  }
  _impl_.inventory_ = nullptr;
}
inline const ::ProtoObject::Inventory& PlayerInfo::_internal_inventory() const {
  const ::ProtoObject::Inventory* p = _impl_.inventory_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoObject::Inventory&>(
      ::ProtoObject::_Inventory_default_instance_);
}
inline const ::ProtoObject::Inventory& PlayerInfo::inventory() const {
  // @@protoc_insertion_point(field_get:ProtoObject.PlayerInfo.inventory)
  return _internal_inventory();
}
inline void PlayerInfo::unsafe_arena_set_allocated_inventory(
    ::ProtoObject::Inventory* inventory) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inventory_);
  }
  _impl_.inventory_ = inventory;
  if (inventory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoObject.PlayerInfo.inventory)
}
inline ::ProtoObject::Inventory* PlayerInfo::release_inventory() {
  
  ::ProtoObject::Inventory* temp = _impl_.inventory_;
  _impl_.inventory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoObject::Inventory* PlayerInfo::unsafe_arena_release_inventory() {
  // @@protoc_insertion_point(field_release:ProtoObject.PlayerInfo.inventory)
  
  ::ProtoObject::Inventory* temp = _impl_.inventory_;
  _impl_.inventory_ = nullptr;
  return temp;
}
inline ::ProtoObject::Inventory* PlayerInfo::_internal_mutable_inventory() {
  
  if (_impl_.inventory_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoObject::Inventory>(GetArenaForAllocation());
    _impl_.inventory_ = p;
  }
  return _impl_.inventory_;
}
inline ::ProtoObject::Inventory* PlayerInfo::mutable_inventory() {
  ::ProtoObject::Inventory* _msg = _internal_mutable_inventory();
  // @@protoc_insertion_point(field_mutable:ProtoObject.PlayerInfo.inventory)
  return _msg;
}
inline void PlayerInfo::set_allocated_inventory(::ProtoObject::Inventory* inventory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inventory_;
  }
  if (inventory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inventory);
    if (message_arena != submessage_arena) {
      inventory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inventory, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.inventory_ = inventory;
  // @@protoc_insertion_point(field_set_allocated:ProtoObject.PlayerInfo.inventory)
}

// repeated .ProtoObject.QuestStatus questStatus = 9;
inline int PlayerInfo::_internal_queststatus_size() const {
  return _impl_.queststatus_.size();
}
inline int PlayerInfo::queststatus_size() const {
  return _internal_queststatus_size();
}
inline void PlayerInfo::clear_queststatus() {
  _impl_.queststatus_.Clear();
}
inline ::ProtoObject::QuestStatus* PlayerInfo::mutable_queststatus(int index) {
  // @@protoc_insertion_point(field_mutable:ProtoObject.PlayerInfo.questStatus)
  return _impl_.queststatus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::QuestStatus >*
PlayerInfo::mutable_queststatus() {
  // @@protoc_insertion_point(field_mutable_list:ProtoObject.PlayerInfo.questStatus)
  return &_impl_.queststatus_;
}
inline const ::ProtoObject::QuestStatus& PlayerInfo::_internal_queststatus(int index) const {
  return _impl_.queststatus_.Get(index);
}
inline const ::ProtoObject::QuestStatus& PlayerInfo::queststatus(int index) const {
  // @@protoc_insertion_point(field_get:ProtoObject.PlayerInfo.questStatus)
  return _internal_queststatus(index);
}
inline ::ProtoObject::QuestStatus* PlayerInfo::_internal_add_queststatus() {
  return _impl_.queststatus_.Add();
}
inline ::ProtoObject::QuestStatus* PlayerInfo::add_queststatus() {
  ::ProtoObject::QuestStatus* _add = _internal_add_queststatus();
  // @@protoc_insertion_point(field_add:ProtoObject.PlayerInfo.questStatus)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoObject::QuestStatus >&
PlayerInfo::queststatus() const {
  // @@protoc_insertion_point(field_list:ProtoObject.PlayerInfo.questStatus)
  return _impl_.queststatus_;
}

// uint64 userIdx = 10;
inline void PlayerInfo::clear_useridx() {
  _impl_.useridx_ = uint64_t{0u};
}
inline uint64_t PlayerInfo::_internal_useridx() const {
  return _impl_.useridx_;
}
inline uint64_t PlayerInfo::useridx() const {
  // @@protoc_insertion_point(field_get:ProtoObject.PlayerInfo.userIdx)
  return _internal_useridx();
}
inline void PlayerInfo::_internal_set_useridx(uint64_t value) {
  
  _impl_.useridx_ = value;
}
inline void PlayerInfo::set_useridx(uint64_t value) {
  _internal_set_useridx(value);
  // @@protoc_insertion_point(field_set:ProtoObject.PlayerInfo.userIdx)
}

// -------------------------------------------------------------------

// Nickname

// string nickname = 1;
inline void Nickname::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& Nickname::nickname() const {
  // @@protoc_insertion_point(field_get:ProtoObject.Nickname.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Nickname::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoObject.Nickname.nickname)
}
inline std::string* Nickname::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:ProtoObject.Nickname.nickname)
  return _s;
}
inline const std::string& Nickname::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void Nickname::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* Nickname::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* Nickname::release_nickname() {
  // @@protoc_insertion_point(field_release:ProtoObject.Nickname.nickname)
  return _impl_.nickname_.Release();
}
inline void Nickname::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoObject.Nickname.nickname)
}

// -------------------------------------------------------------------

// Location

// uint64 userIdx = 1;
inline void Location::clear_useridx() {
  _impl_.useridx_ = uint64_t{0u};
}
inline uint64_t Location::_internal_useridx() const {
  return _impl_.useridx_;
}
inline uint64_t Location::useridx() const {
  // @@protoc_insertion_point(field_get:ProtoObject.Location.userIdx)
  return _internal_useridx();
}
inline void Location::_internal_set_useridx(uint64_t value) {
  
  _impl_.useridx_ = value;
}
inline void Location::set_useridx(uint64_t value) {
  _internal_set_useridx(value);
  // @@protoc_insertion_point(field_set:ProtoObject.Location.userIdx)
}

// float x = 2;
inline void Location::clear_x() {
  _impl_.x_ = 0;
}
inline float Location::_internal_x() const {
  return _impl_.x_;
}
inline float Location::x() const {
  // @@protoc_insertion_point(field_get:ProtoObject.Location.x)
  return _internal_x();
}
inline void Location::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Location::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ProtoObject.Location.x)
}

// float y = 3;
inline void Location::clear_y() {
  _impl_.y_ = 0;
}
inline float Location::_internal_y() const {
  return _impl_.y_;
}
inline float Location::y() const {
  // @@protoc_insertion_point(field_get:ProtoObject.Location.y)
  return _internal_y();
}
inline void Location::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Location::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ProtoObject.Location.y)
}

// float z = 4;
inline void Location::clear_z() {
  _impl_.z_ = 0;
}
inline float Location::_internal_z() const {
  return _impl_.z_;
}
inline float Location::z() const {
  // @@protoc_insertion_point(field_get:ProtoObject.Location.z)
  return _internal_z();
}
inline void Location::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Location::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:ProtoObject.Location.z)
}

// float pitch = 5;
inline void Location::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float Location::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float Location::pitch() const {
  // @@protoc_insertion_point(field_get:ProtoObject.Location.pitch)
  return _internal_pitch();
}
inline void Location::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void Location::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:ProtoObject.Location.pitch)
}

// float yaw = 6;
inline void Location::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float Location::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float Location::yaw() const {
  // @@protoc_insertion_point(field_get:ProtoObject.Location.yaw)
  return _internal_yaw();
}
inline void Location::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void Location::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:ProtoObject.Location.yaw)
}

// -------------------------------------------------------------------

// RepBoolean

// uint64 userIdx = 1;
inline void RepBoolean::clear_useridx() {
  _impl_.useridx_ = uint64_t{0u};
}
inline uint64_t RepBoolean::_internal_useridx() const {
  return _impl_.useridx_;
}
inline uint64_t RepBoolean::useridx() const {
  // @@protoc_insertion_point(field_get:ProtoObject.RepBoolean.userIdx)
  return _internal_useridx();
}
inline void RepBoolean::_internal_set_useridx(uint64_t value) {
  
  _impl_.useridx_ = value;
}
inline void RepBoolean::set_useridx(uint64_t value) {
  _internal_set_useridx(value);
  // @@protoc_insertion_point(field_set:ProtoObject.RepBoolean.userIdx)
}

// .ProtoObject.RepBoolean.RepType type = 2;
inline void RepBoolean::clear_type() {
  _impl_.type_ = 0;
}
inline ::ProtoObject::RepBoolean_RepType RepBoolean::_internal_type() const {
  return static_cast< ::ProtoObject::RepBoolean_RepType >(_impl_.type_);
}
inline ::ProtoObject::RepBoolean_RepType RepBoolean::type() const {
  // @@protoc_insertion_point(field_get:ProtoObject.RepBoolean.type)
  return _internal_type();
}
inline void RepBoolean::_internal_set_type(::ProtoObject::RepBoolean_RepType value) {
  
  _impl_.type_ = value;
}
inline void RepBoolean::set_type(::ProtoObject::RepBoolean_RepType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ProtoObject.RepBoolean.type)
}

// bool boolean = 3;
inline void RepBoolean::clear_boolean() {
  _impl_.boolean_ = false;
}
inline bool RepBoolean::_internal_boolean() const {
  return _impl_.boolean_;
}
inline bool RepBoolean::boolean() const {
  // @@protoc_insertion_point(field_get:ProtoObject.RepBoolean.boolean)
  return _internal_boolean();
}
inline void RepBoolean::_internal_set_boolean(bool value) {
  
  _impl_.boolean_ = value;
}
inline void RepBoolean::set_boolean(bool value) {
  _internal_set_boolean(value);
  // @@protoc_insertion_point(field_set:ProtoObject.RepBoolean.boolean)
}

// -------------------------------------------------------------------

// Equipment

// uint64 userIdx = 1;
inline void Equipment::clear_useridx() {
  _impl_.useridx_ = uint64_t{0u};
}
inline uint64_t Equipment::_internal_useridx() const {
  return _impl_.useridx_;
}
inline uint64_t Equipment::useridx() const {
  // @@protoc_insertion_point(field_get:ProtoObject.Equipment.userIdx)
  return _internal_useridx();
}
inline void Equipment::_internal_set_useridx(uint64_t value) {
  
  _impl_.useridx_ = value;
}
inline void Equipment::set_useridx(uint64_t value) {
  _internal_set_useridx(value);
  // @@protoc_insertion_point(field_set:ProtoObject.Equipment.userIdx)
}

// .ProtoObject.Equipment.EquipmentType equipType = 2;
inline void Equipment::clear_equiptype() {
  _impl_.equiptype_ = 0;
}
inline ::ProtoObject::Equipment_EquipmentType Equipment::_internal_equiptype() const {
  return static_cast< ::ProtoObject::Equipment_EquipmentType >(_impl_.equiptype_);
}
inline ::ProtoObject::Equipment_EquipmentType Equipment::equiptype() const {
  // @@protoc_insertion_point(field_get:ProtoObject.Equipment.equipType)
  return _internal_equiptype();
}
inline void Equipment::_internal_set_equiptype(::ProtoObject::Equipment_EquipmentType value) {
  
  _impl_.equiptype_ = value;
}
inline void Equipment::set_equiptype(::ProtoObject::Equipment_EquipmentType value) {
  _internal_set_equiptype(value);
  // @@protoc_insertion_point(field_set:ProtoObject.Equipment.equipType)
}

// uint64 itemIndex = 3;
inline void Equipment::clear_itemindex() {
  _impl_.itemindex_ = uint64_t{0u};
}
inline uint64_t Equipment::_internal_itemindex() const {
  return _impl_.itemindex_;
}
inline uint64_t Equipment::itemindex() const {
  // @@protoc_insertion_point(field_get:ProtoObject.Equipment.itemIndex)
  return _internal_itemindex();
}
inline void Equipment::_internal_set_itemindex(uint64_t value) {
  
  _impl_.itemindex_ = value;
}
inline void Equipment::set_itemindex(uint64_t value) {
  _internal_set_itemindex(value);
  // @@protoc_insertion_point(field_set:ProtoObject.Equipment.itemIndex)
}

// -------------------------------------------------------------------

// ResourceChange

// uint32 mapIdx = 1;
inline void ResourceChange::clear_mapidx() {
  _impl_.mapidx_ = 0u;
}
inline uint32_t ResourceChange::_internal_mapidx() const {
  return _impl_.mapidx_;
}
inline uint32_t ResourceChange::mapidx() const {
  // @@protoc_insertion_point(field_get:ProtoObject.ResourceChange.mapIdx)
  return _internal_mapidx();
}
inline void ResourceChange::_internal_set_mapidx(uint32_t value) {
  
  _impl_.mapidx_ = value;
}
inline void ResourceChange::set_mapidx(uint32_t value) {
  _internal_set_mapidx(value);
  // @@protoc_insertion_point(field_set:ProtoObject.ResourceChange.mapIdx)
}

// .ProtoObject.ResourceChange.ResourceType resType = 2;
inline void ResourceChange::clear_restype() {
  _impl_.restype_ = 0;
}
inline ::ProtoObject::ResourceChange_ResourceType ResourceChange::_internal_restype() const {
  return static_cast< ::ProtoObject::ResourceChange_ResourceType >(_impl_.restype_);
}
inline ::ProtoObject::ResourceChange_ResourceType ResourceChange::restype() const {
  // @@protoc_insertion_point(field_get:ProtoObject.ResourceChange.resType)
  return _internal_restype();
}
inline void ResourceChange::_internal_set_restype(::ProtoObject::ResourceChange_ResourceType value) {
  
  _impl_.restype_ = value;
}
inline void ResourceChange::set_restype(::ProtoObject::ResourceChange_ResourceType value) {
  _internal_set_restype(value);
  // @@protoc_insertion_point(field_set:ProtoObject.ResourceChange.resType)
}

// .ProtoObject.ResourceChange.ChangeType resChangeType = 3;
inline void ResourceChange::clear_reschangetype() {
  _impl_.reschangetype_ = 0;
}
inline ::ProtoObject::ResourceChange_ChangeType ResourceChange::_internal_reschangetype() const {
  return static_cast< ::ProtoObject::ResourceChange_ChangeType >(_impl_.reschangetype_);
}
inline ::ProtoObject::ResourceChange_ChangeType ResourceChange::reschangetype() const {
  // @@protoc_insertion_point(field_get:ProtoObject.ResourceChange.resChangeType)
  return _internal_reschangetype();
}
inline void ResourceChange::_internal_set_reschangetype(::ProtoObject::ResourceChange_ChangeType value) {
  
  _impl_.reschangetype_ = value;
}
inline void ResourceChange::set_reschangetype(::ProtoObject::ResourceChange_ChangeType value) {
  _internal_set_reschangetype(value);
  // @@protoc_insertion_point(field_set:ProtoObject.ResourceChange.resChangeType)
}

// uint64 resIdx = 4;
inline void ResourceChange::clear_residx() {
  _impl_.residx_ = uint64_t{0u};
}
inline uint64_t ResourceChange::_internal_residx() const {
  return _impl_.residx_;
}
inline uint64_t ResourceChange::residx() const {
  // @@protoc_insertion_point(field_get:ProtoObject.ResourceChange.resIdx)
  return _internal_residx();
}
inline void ResourceChange::_internal_set_residx(uint64_t value) {
  
  _impl_.residx_ = value;
}
inline void ResourceChange::set_residx(uint64_t value) {
  _internal_set_residx(value);
  // @@protoc_insertion_point(field_set:ProtoObject.ResourceChange.resIdx)
}

// -------------------------------------------------------------------

// MapTransition

// uint64 userIdx = 1;
inline void MapTransition::clear_useridx() {
  _impl_.useridx_ = uint64_t{0u};
}
inline uint64_t MapTransition::_internal_useridx() const {
  return _impl_.useridx_;
}
inline uint64_t MapTransition::useridx() const {
  // @@protoc_insertion_point(field_get:ProtoObject.MapTransition.userIdx)
  return _internal_useridx();
}
inline void MapTransition::_internal_set_useridx(uint64_t value) {
  
  _impl_.useridx_ = value;
}
inline void MapTransition::set_useridx(uint64_t value) {
  _internal_set_useridx(value);
  // @@protoc_insertion_point(field_set:ProtoObject.MapTransition.userIdx)
}

// uint32 before = 2;
inline void MapTransition::clear_before() {
  _impl_.before_ = 0u;
}
inline uint32_t MapTransition::_internal_before() const {
  return _impl_.before_;
}
inline uint32_t MapTransition::before() const {
  // @@protoc_insertion_point(field_get:ProtoObject.MapTransition.before)
  return _internal_before();
}
inline void MapTransition::_internal_set_before(uint32_t value) {
  
  _impl_.before_ = value;
}
inline void MapTransition::set_before(uint32_t value) {
  _internal_set_before(value);
  // @@protoc_insertion_point(field_set:ProtoObject.MapTransition.before)
}

// uint32 after = 3;
inline void MapTransition::clear_after() {
  _impl_.after_ = 0u;
}
inline uint32_t MapTransition::_internal_after() const {
  return _impl_.after_;
}
inline uint32_t MapTransition::after() const {
  // @@protoc_insertion_point(field_get:ProtoObject.MapTransition.after)
  return _internal_after();
}
inline void MapTransition::_internal_set_after(uint32_t value) {
  
  _impl_.after_ = value;
}
inline void MapTransition::set_after(uint32_t value) {
  _internal_set_after(value);
  // @@protoc_insertion_point(field_set:ProtoObject.MapTransition.after)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoObject

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ProtoObject::Inventory_ItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoObject::Inventory_ItemType>() {
  return ::ProtoObject::Inventory_ItemType_descriptor();
}
template <> struct is_proto_enum< ::ProtoObject::QuestStatus_SubQuestStatus_SubQuestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoObject::QuestStatus_SubQuestStatus_SubQuestType>() {
  return ::ProtoObject::QuestStatus_SubQuestStatus_SubQuestType_descriptor();
}
template <> struct is_proto_enum< ::ProtoObject::QuestStatus_QuestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoObject::QuestStatus_QuestType>() {
  return ::ProtoObject::QuestStatus_QuestType_descriptor();
}
template <> struct is_proto_enum< ::ProtoObject::QuestStatus_QuestProgressType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoObject::QuestStatus_QuestProgressType>() {
  return ::ProtoObject::QuestStatus_QuestProgressType_descriptor();
}
template <> struct is_proto_enum< ::ProtoObject::RepBoolean_RepType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoObject::RepBoolean_RepType>() {
  return ::ProtoObject::RepBoolean_RepType_descriptor();
}
template <> struct is_proto_enum< ::ProtoObject::Equipment_EquipmentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoObject::Equipment_EquipmentType>() {
  return ::ProtoObject::Equipment_EquipmentType_descriptor();
}
template <> struct is_proto_enum< ::ProtoObject::ResourceChange_ResourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoObject::ResourceChange_ResourceType>() {
  return ::ProtoObject::ResourceChange_ResourceType_descriptor();
}
template <> struct is_proto_enum< ::ProtoObject::ResourceChange_ChangeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoObject::ResourceChange_ChangeType>() {
  return ::ProtoObject::ResourceChange_ChangeType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ProtoObject_2eproto
