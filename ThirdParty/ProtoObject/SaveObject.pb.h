// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SaveObject.proto
#pragma once 

#ifndef GOOGLE_PROTOBUF_INCLUDED_SaveObject_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_SaveObject_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_SaveObject_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_SaveObject_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_SaveObject_2eproto;
namespace SaveObject {
class GameItem;
struct GameItemDefaultTypeInternal;
extern GameItemDefaultTypeInternal _GameItem_default_instance_;
class Inventory;
struct InventoryDefaultTypeInternal;
extern InventoryDefaultTypeInternal _Inventory_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class QuestStatus;
struct QuestStatusDefaultTypeInternal;
extern QuestStatusDefaultTypeInternal _QuestStatus_default_instance_;
class QuestStatus_SubQuestStatus;
struct QuestStatus_SubQuestStatusDefaultTypeInternal;
extern QuestStatus_SubQuestStatusDefaultTypeInternal _QuestStatus_SubQuestStatus_default_instance_;
class TypeInventory;
struct TypeInventoryDefaultTypeInternal;
extern TypeInventoryDefaultTypeInternal _TypeInventory_default_instance_;
}  // namespace SaveObject
PROTOBUF_NAMESPACE_OPEN
template<> ::SaveObject::GameItem* Arena::CreateMaybeMessage<::SaveObject::GameItem>(Arena*);
template<> ::SaveObject::Inventory* Arena::CreateMaybeMessage<::SaveObject::Inventory>(Arena*);
template<> ::SaveObject::PlayerInfo* Arena::CreateMaybeMessage<::SaveObject::PlayerInfo>(Arena*);
template<> ::SaveObject::QuestStatus* Arena::CreateMaybeMessage<::SaveObject::QuestStatus>(Arena*);
template<> ::SaveObject::QuestStatus_SubQuestStatus* Arena::CreateMaybeMessage<::SaveObject::QuestStatus_SubQuestStatus>(Arena*);
template<> ::SaveObject::TypeInventory* Arena::CreateMaybeMessage<::SaveObject::TypeInventory>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace SaveObject {

enum Inventory_ItemType : int {
  Inventory_ItemType_CLOTH = 0,
  Inventory_ItemType_WEAPON = 1,
  Inventory_ItemType_ITEM = 2,
  Inventory_ItemType_Inventory_ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Inventory_ItemType_Inventory_ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Inventory_ItemType_IsValid(int value);
constexpr Inventory_ItemType Inventory_ItemType_ItemType_MIN = Inventory_ItemType_CLOTH;
constexpr Inventory_ItemType Inventory_ItemType_ItemType_MAX = Inventory_ItemType_ITEM;
constexpr int Inventory_ItemType_ItemType_ARRAYSIZE = Inventory_ItemType_ItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Inventory_ItemType_descriptor();
template<typename T>
inline const std::string& Inventory_ItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Inventory_ItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Inventory_ItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Inventory_ItemType_descriptor(), enum_t_value);
}
inline bool Inventory_ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Inventory_ItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Inventory_ItemType>(
    Inventory_ItemType_descriptor(), name, value);
}
enum QuestStatus_SubQuestStatus_SubQuestType : int {
  QuestStatus_SubQuestStatus_SubQuestType_ARRIVAL = 0,
  QuestStatus_SubQuestStatus_SubQuestType_HUNT = 1,
  QuestStatus_SubQuestStatus_SubQuestType_ITEM = 2,
  QuestStatus_SubQuestStatus_SubQuestType_ACTION = 3,
  QuestStatus_SubQuestStatus_SubQuestType_QuestStatus_SubQuestStatus_SubQuestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  QuestStatus_SubQuestStatus_SubQuestType_QuestStatus_SubQuestStatus_SubQuestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool QuestStatus_SubQuestStatus_SubQuestType_IsValid(int value);
constexpr QuestStatus_SubQuestStatus_SubQuestType QuestStatus_SubQuestStatus_SubQuestType_SubQuestType_MIN = QuestStatus_SubQuestStatus_SubQuestType_ARRIVAL;
constexpr QuestStatus_SubQuestStatus_SubQuestType QuestStatus_SubQuestStatus_SubQuestType_SubQuestType_MAX = QuestStatus_SubQuestStatus_SubQuestType_ACTION;
constexpr int QuestStatus_SubQuestStatus_SubQuestType_SubQuestType_ARRAYSIZE = QuestStatus_SubQuestStatus_SubQuestType_SubQuestType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestStatus_SubQuestStatus_SubQuestType_descriptor();
template<typename T>
inline const std::string& QuestStatus_SubQuestStatus_SubQuestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestStatus_SubQuestStatus_SubQuestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestStatus_SubQuestStatus_SubQuestType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestStatus_SubQuestStatus_SubQuestType_descriptor(), enum_t_value);
}
inline bool QuestStatus_SubQuestStatus_SubQuestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestStatus_SubQuestStatus_SubQuestType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestStatus_SubQuestStatus_SubQuestType>(
    QuestStatus_SubQuestStatus_SubQuestType_descriptor(), name, value);
}
enum QuestStatus_QuestType : int {
  QuestStatus_QuestType_SERIAL = 0,
  QuestStatus_QuestType_PARALLEL = 1,
  QuestStatus_QuestType_QuestStatus_QuestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  QuestStatus_QuestType_QuestStatus_QuestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool QuestStatus_QuestType_IsValid(int value);
constexpr QuestStatus_QuestType QuestStatus_QuestType_QuestType_MIN = QuestStatus_QuestType_SERIAL;
constexpr QuestStatus_QuestType QuestStatus_QuestType_QuestType_MAX = QuestStatus_QuestType_PARALLEL;
constexpr int QuestStatus_QuestType_QuestType_ARRAYSIZE = QuestStatus_QuestType_QuestType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestStatus_QuestType_descriptor();
template<typename T>
inline const std::string& QuestStatus_QuestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestStatus_QuestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestStatus_QuestType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestStatus_QuestType_descriptor(), enum_t_value);
}
inline bool QuestStatus_QuestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestStatus_QuestType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestStatus_QuestType>(
    QuestStatus_QuestType_descriptor(), name, value);
}
enum QuestStatus_QuestProgressType : int {
  QuestStatus_QuestProgressType_UNAVAILABLE = 0,
  QuestStatus_QuestProgressType_AVAILABLE = 1,
  QuestStatus_QuestProgressType_INPROGRESS = 2,
  QuestStatus_QuestProgressType_COMPLETABLE = 3,
  QuestStatus_QuestProgressType_COMPLETED = 4,
  QuestStatus_QuestProgressType_QuestStatus_QuestProgressType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  QuestStatus_QuestProgressType_QuestStatus_QuestProgressType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool QuestStatus_QuestProgressType_IsValid(int value);
constexpr QuestStatus_QuestProgressType QuestStatus_QuestProgressType_QuestProgressType_MIN = QuestStatus_QuestProgressType_UNAVAILABLE;
constexpr QuestStatus_QuestProgressType QuestStatus_QuestProgressType_QuestProgressType_MAX = QuestStatus_QuestProgressType_COMPLETED;
constexpr int QuestStatus_QuestProgressType_QuestProgressType_ARRAYSIZE = QuestStatus_QuestProgressType_QuestProgressType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestStatus_QuestProgressType_descriptor();
template<typename T>
inline const std::string& QuestStatus_QuestProgressType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestStatus_QuestProgressType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestStatus_QuestProgressType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestStatus_QuestProgressType_descriptor(), enum_t_value);
}
inline bool QuestStatus_QuestProgressType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestStatus_QuestProgressType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestStatus_QuestProgressType>(
    QuestStatus_QuestProgressType_descriptor(), name, value);
}
// ===================================================================

class GameItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SaveObject.GameItem) */ {
 public:
  inline GameItem() : GameItem(nullptr) {}
  ~GameItem() override;
  explicit PROTOBUF_CONSTEXPR GameItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameItem(const GameItem& from);
  GameItem(GameItem&& from) noexcept
    : GameItem() {
    *this = ::std::move(from);
  }

  inline GameItem& operator=(const GameItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameItem& operator=(GameItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameItem* internal_default_instance() {
    return reinterpret_cast<const GameItem*>(
               &_GameItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GameItem& a, GameItem& b) {
    a.Swap(&b);
  }
  inline void Swap(GameItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameItem& from) {
    GameItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SaveObject.GameItem";
  }
  protected:
  explicit GameItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kNumFieldNumber = 2,
  };
  // uint64 index = 1;
  void clear_index();
  uint64_t index() const;
  void set_index(uint64_t value);
  private:
  uint64_t _internal_index() const;
  void _internal_set_index(uint64_t value);
  public:

  // uint64 num = 2;
  void clear_num();
  uint64_t num() const;
  void set_num(uint64_t value);
  private:
  uint64_t _internal_num() const;
  void _internal_set_num(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SaveObject.GameItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t index_;
    uint64_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SaveObject_2eproto;
};
// -------------------------------------------------------------------

class TypeInventory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SaveObject.TypeInventory) */ {
 public:
  inline TypeInventory() : TypeInventory(nullptr) {}
  ~TypeInventory() override;
  explicit PROTOBUF_CONSTEXPR TypeInventory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypeInventory(const TypeInventory& from);
  TypeInventory(TypeInventory&& from) noexcept
    : TypeInventory() {
    *this = ::std::move(from);
  }

  inline TypeInventory& operator=(const TypeInventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeInventory& operator=(TypeInventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeInventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypeInventory* internal_default_instance() {
    return reinterpret_cast<const TypeInventory*>(
               &_TypeInventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TypeInventory& a, TypeInventory& b) {
    a.Swap(&b);
  }
  inline void Swap(TypeInventory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeInventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeInventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypeInventory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TypeInventory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TypeInventory& from) {
    TypeInventory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeInventory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SaveObject.TypeInventory";
  }
  protected:
  explicit TypeInventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .SaveObject.GameItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::SaveObject::GameItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::GameItem >*
      mutable_items();
  private:
  const ::SaveObject::GameItem& _internal_items(int index) const;
  ::SaveObject::GameItem* _internal_add_items();
  public:
  const ::SaveObject::GameItem& items(int index) const;
  ::SaveObject::GameItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::GameItem >&
      items() const;

  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SaveObject.TypeInventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::GameItem > items_;
    uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SaveObject_2eproto;
};
// -------------------------------------------------------------------

class Inventory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SaveObject.Inventory) */ {
 public:
  inline Inventory() : Inventory(nullptr) {}
  ~Inventory() override;
  explicit PROTOBUF_CONSTEXPR Inventory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Inventory(const Inventory& from);
  Inventory(Inventory&& from) noexcept
    : Inventory() {
    *this = ::std::move(from);
  }

  inline Inventory& operator=(const Inventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Inventory& operator=(Inventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Inventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const Inventory* internal_default_instance() {
    return reinterpret_cast<const Inventory*>(
               &_Inventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Inventory& a, Inventory& b) {
    a.Swap(&b);
  }
  inline void Swap(Inventory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Inventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Inventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Inventory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Inventory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Inventory& from) {
    Inventory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Inventory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SaveObject.Inventory";
  }
  protected:
  explicit Inventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Inventory_ItemType ItemType;
  static constexpr ItemType CLOTH =
    Inventory_ItemType_CLOTH;
  static constexpr ItemType WEAPON =
    Inventory_ItemType_WEAPON;
  static constexpr ItemType ITEM =
    Inventory_ItemType_ITEM;
  static inline bool ItemType_IsValid(int value) {
    return Inventory_ItemType_IsValid(value);
  }
  static constexpr ItemType ItemType_MIN =
    Inventory_ItemType_ItemType_MIN;
  static constexpr ItemType ItemType_MAX =
    Inventory_ItemType_ItemType_MAX;
  static constexpr int ItemType_ARRAYSIZE =
    Inventory_ItemType_ItemType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ItemType_descriptor() {
    return Inventory_ItemType_descriptor();
  }
  template<typename T>
  static inline const std::string& ItemType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ItemType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ItemType_Name.");
    return Inventory_ItemType_Name(enum_t_value);
  }
  static inline bool ItemType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ItemType* value) {
    return Inventory_ItemType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeInventoryFieldNumber = 1,
  };
  // repeated .SaveObject.TypeInventory typeInventory = 1;
  int typeinventory_size() const;
  private:
  int _internal_typeinventory_size() const;
  public:
  void clear_typeinventory();
  ::SaveObject::TypeInventory* mutable_typeinventory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::TypeInventory >*
      mutable_typeinventory();
  private:
  const ::SaveObject::TypeInventory& _internal_typeinventory(int index) const;
  ::SaveObject::TypeInventory* _internal_add_typeinventory();
  public:
  const ::SaveObject::TypeInventory& typeinventory(int index) const;
  ::SaveObject::TypeInventory* add_typeinventory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::TypeInventory >&
      typeinventory() const;

  // @@protoc_insertion_point(class_scope:SaveObject.Inventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::TypeInventory > typeinventory_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SaveObject_2eproto;
};
// -------------------------------------------------------------------

class QuestStatus_SubQuestStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SaveObject.QuestStatus.SubQuestStatus) */ {
 public:
  inline QuestStatus_SubQuestStatus() : QuestStatus_SubQuestStatus(nullptr) {}
  ~QuestStatus_SubQuestStatus() override;
  explicit PROTOBUF_CONSTEXPR QuestStatus_SubQuestStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuestStatus_SubQuestStatus(const QuestStatus_SubQuestStatus& from);
  QuestStatus_SubQuestStatus(QuestStatus_SubQuestStatus&& from) noexcept
    : QuestStatus_SubQuestStatus() {
    *this = ::std::move(from);
  }

  inline QuestStatus_SubQuestStatus& operator=(const QuestStatus_SubQuestStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuestStatus_SubQuestStatus& operator=(QuestStatus_SubQuestStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuestStatus_SubQuestStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuestStatus_SubQuestStatus* internal_default_instance() {
    return reinterpret_cast<const QuestStatus_SubQuestStatus*>(
               &_QuestStatus_SubQuestStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(QuestStatus_SubQuestStatus& a, QuestStatus_SubQuestStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(QuestStatus_SubQuestStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuestStatus_SubQuestStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuestStatus_SubQuestStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuestStatus_SubQuestStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuestStatus_SubQuestStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuestStatus_SubQuestStatus& from) {
    QuestStatus_SubQuestStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuestStatus_SubQuestStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SaveObject.QuestStatus.SubQuestStatus";
  }
  protected:
  explicit QuestStatus_SubQuestStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef QuestStatus_SubQuestStatus_SubQuestType SubQuestType;
  static constexpr SubQuestType ARRIVAL =
    QuestStatus_SubQuestStatus_SubQuestType_ARRIVAL;
  static constexpr SubQuestType HUNT =
    QuestStatus_SubQuestStatus_SubQuestType_HUNT;
  static constexpr SubQuestType ITEM =
    QuestStatus_SubQuestStatus_SubQuestType_ITEM;
  static constexpr SubQuestType ACTION =
    QuestStatus_SubQuestStatus_SubQuestType_ACTION;
  static inline bool SubQuestType_IsValid(int value) {
    return QuestStatus_SubQuestStatus_SubQuestType_IsValid(value);
  }
  static constexpr SubQuestType SubQuestType_MIN =
    QuestStatus_SubQuestStatus_SubQuestType_SubQuestType_MIN;
  static constexpr SubQuestType SubQuestType_MAX =
    QuestStatus_SubQuestStatus_SubQuestType_SubQuestType_MAX;
  static constexpr int SubQuestType_ARRAYSIZE =
    QuestStatus_SubQuestStatus_SubQuestType_SubQuestType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SubQuestType_descriptor() {
    return QuestStatus_SubQuestStatus_SubQuestType_descriptor();
  }
  template<typename T>
  static inline const std::string& SubQuestType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SubQuestType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SubQuestType_Name.");
    return QuestStatus_SubQuestStatus_SubQuestType_Name(enum_t_value);
  }
  static inline bool SubQuestType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SubQuestType* value) {
    return QuestStatus_SubQuestStatus_SubQuestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kBStartedFieldNumber = 2,
    kBCompletedFieldNumber = 3,
    kCurrAmountFieldNumber = 4,
  };
  // .SaveObject.QuestStatus.SubQuestStatus.SubQuestType type = 1;
  void clear_type();
  ::SaveObject::QuestStatus_SubQuestStatus_SubQuestType type() const;
  void set_type(::SaveObject::QuestStatus_SubQuestStatus_SubQuestType value);
  private:
  ::SaveObject::QuestStatus_SubQuestStatus_SubQuestType _internal_type() const;
  void _internal_set_type(::SaveObject::QuestStatus_SubQuestStatus_SubQuestType value);
  public:

  // bool bStarted = 2;
  void clear_bstarted();
  bool bstarted() const;
  void set_bstarted(bool value);
  private:
  bool _internal_bstarted() const;
  void _internal_set_bstarted(bool value);
  public:

  // bool bCompleted = 3;
  void clear_bcompleted();
  bool bcompleted() const;
  void set_bcompleted(bool value);
  private:
  bool _internal_bcompleted() const;
  void _internal_set_bcompleted(bool value);
  public:

  // uint32 currAmount = 4;
  void clear_curramount();
  uint32_t curramount() const;
  void set_curramount(uint32_t value);
  private:
  uint32_t _internal_curramount() const;
  void _internal_set_curramount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SaveObject.QuestStatus.SubQuestStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    bool bstarted_;
    bool bcompleted_;
    uint32_t curramount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SaveObject_2eproto;
};
// -------------------------------------------------------------------

class QuestStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SaveObject.QuestStatus) */ {
 public:
  inline QuestStatus() : QuestStatus(nullptr) {}
  ~QuestStatus() override;
  explicit PROTOBUF_CONSTEXPR QuestStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuestStatus(const QuestStatus& from);
  QuestStatus(QuestStatus&& from) noexcept
    : QuestStatus() {
    *this = ::std::move(from);
  }

  inline QuestStatus& operator=(const QuestStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuestStatus& operator=(QuestStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuestStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuestStatus* internal_default_instance() {
    return reinterpret_cast<const QuestStatus*>(
               &_QuestStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(QuestStatus& a, QuestStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(QuestStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuestStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuestStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuestStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuestStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuestStatus& from) {
    QuestStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuestStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SaveObject.QuestStatus";
  }
  protected:
  explicit QuestStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef QuestStatus_SubQuestStatus SubQuestStatus;

  typedef QuestStatus_QuestType QuestType;
  static constexpr QuestType SERIAL =
    QuestStatus_QuestType_SERIAL;
  static constexpr QuestType PARALLEL =
    QuestStatus_QuestType_PARALLEL;
  static inline bool QuestType_IsValid(int value) {
    return QuestStatus_QuestType_IsValid(value);
  }
  static constexpr QuestType QuestType_MIN =
    QuestStatus_QuestType_QuestType_MIN;
  static constexpr QuestType QuestType_MAX =
    QuestStatus_QuestType_QuestType_MAX;
  static constexpr int QuestType_ARRAYSIZE =
    QuestStatus_QuestType_QuestType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  QuestType_descriptor() {
    return QuestStatus_QuestType_descriptor();
  }
  template<typename T>
  static inline const std::string& QuestType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, QuestType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function QuestType_Name.");
    return QuestStatus_QuestType_Name(enum_t_value);
  }
  static inline bool QuestType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      QuestType* value) {
    return QuestStatus_QuestType_Parse(name, value);
  }

  typedef QuestStatus_QuestProgressType QuestProgressType;
  static constexpr QuestProgressType UNAVAILABLE =
    QuestStatus_QuestProgressType_UNAVAILABLE;
  static constexpr QuestProgressType AVAILABLE =
    QuestStatus_QuestProgressType_AVAILABLE;
  static constexpr QuestProgressType INPROGRESS =
    QuestStatus_QuestProgressType_INPROGRESS;
  static constexpr QuestProgressType COMPLETABLE =
    QuestStatus_QuestProgressType_COMPLETABLE;
  static constexpr QuestProgressType COMPLETED =
    QuestStatus_QuestProgressType_COMPLETED;
  static inline bool QuestProgressType_IsValid(int value) {
    return QuestStatus_QuestProgressType_IsValid(value);
  }
  static constexpr QuestProgressType QuestProgressType_MIN =
    QuestStatus_QuestProgressType_QuestProgressType_MIN;
  static constexpr QuestProgressType QuestProgressType_MAX =
    QuestStatus_QuestProgressType_QuestProgressType_MAX;
  static constexpr int QuestProgressType_ARRAYSIZE =
    QuestStatus_QuestProgressType_QuestProgressType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  QuestProgressType_descriptor() {
    return QuestStatus_QuestProgressType_descriptor();
  }
  template<typename T>
  static inline const std::string& QuestProgressType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, QuestProgressType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function QuestProgressType_Name.");
    return QuestStatus_QuestProgressType_Name(enum_t_value);
  }
  static inline bool QuestProgressType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      QuestProgressType* value) {
    return QuestStatus_QuestProgressType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSubStatusFieldNumber = 4,
    kIndexFieldNumber = 1,
    kTypeFieldNumber = 2,
    kProgressTypeFieldNumber = 3,
    kCurrPhaseFieldNumber = 5,
    kCompletedFieldNumber = 6,
  };
  // repeated .SaveObject.QuestStatus.SubQuestStatus subStatus = 4;
  int substatus_size() const;
  private:
  int _internal_substatus_size() const;
  public:
  void clear_substatus();
  ::SaveObject::QuestStatus_SubQuestStatus* mutable_substatus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::QuestStatus_SubQuestStatus >*
      mutable_substatus();
  private:
  const ::SaveObject::QuestStatus_SubQuestStatus& _internal_substatus(int index) const;
  ::SaveObject::QuestStatus_SubQuestStatus* _internal_add_substatus();
  public:
  const ::SaveObject::QuestStatus_SubQuestStatus& substatus(int index) const;
  ::SaveObject::QuestStatus_SubQuestStatus* add_substatus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::QuestStatus_SubQuestStatus >&
      substatus() const;

  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // .SaveObject.QuestStatus.QuestType type = 2;
  void clear_type();
  ::SaveObject::QuestStatus_QuestType type() const;
  void set_type(::SaveObject::QuestStatus_QuestType value);
  private:
  ::SaveObject::QuestStatus_QuestType _internal_type() const;
  void _internal_set_type(::SaveObject::QuestStatus_QuestType value);
  public:

  // .SaveObject.QuestStatus.QuestProgressType progressType = 3;
  void clear_progresstype();
  ::SaveObject::QuestStatus_QuestProgressType progresstype() const;
  void set_progresstype(::SaveObject::QuestStatus_QuestProgressType value);
  private:
  ::SaveObject::QuestStatus_QuestProgressType _internal_progresstype() const;
  void _internal_set_progresstype(::SaveObject::QuestStatus_QuestProgressType value);
  public:

  // uint32 currPhase = 5;
  void clear_currphase();
  uint32_t currphase() const;
  void set_currphase(uint32_t value);
  private:
  uint32_t _internal_currphase() const;
  void _internal_set_currphase(uint32_t value);
  public:

  // uint32 completed = 6;
  void clear_completed();
  uint32_t completed() const;
  void set_completed(uint32_t value);
  private:
  uint32_t _internal_completed() const;
  void _internal_set_completed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SaveObject.QuestStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::QuestStatus_SubQuestStatus > substatus_;
    uint32_t index_;
    int type_;
    int progresstype_;
    uint32_t currphase_;
    uint32_t completed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SaveObject_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SaveObject.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  explicit PROTOBUF_CONSTEXPR PlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerInfo& from) {
    PlayerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SaveObject.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestStatusFieldNumber = 9,
    kNameFieldNumber = 1,
    kInventoryFieldNumber = 8,
    kLevelFieldNumber = 2,
    kMapFieldNumber = 3,
    kLocXFieldNumber = 4,
    kLocYFieldNumber = 5,
    kGoldFieldNumber = 7,
    kLocZFieldNumber = 6,
    kSlotIndexFieldNumber = 10,
  };
  // repeated .SaveObject.QuestStatus questStatus = 9;
  int queststatus_size() const;
  private:
  int _internal_queststatus_size() const;
  public:
  void clear_queststatus();
  ::SaveObject::QuestStatus* mutable_queststatus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::QuestStatus >*
      mutable_queststatus();
  private:
  const ::SaveObject::QuestStatus& _internal_queststatus(int index) const;
  ::SaveObject::QuestStatus* _internal_add_queststatus();
  public:
  const ::SaveObject::QuestStatus& queststatus(int index) const;
  ::SaveObject::QuestStatus* add_queststatus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::QuestStatus >&
      queststatus() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .SaveObject.Inventory inventory = 8;
  bool has_inventory() const;
  private:
  bool _internal_has_inventory() const;
  public:
  void clear_inventory();
  const ::SaveObject::Inventory& inventory() const;
  PROTOBUF_NODISCARD ::SaveObject::Inventory* release_inventory();
  ::SaveObject::Inventory* mutable_inventory();
  void set_allocated_inventory(::SaveObject::Inventory* inventory);
  private:
  const ::SaveObject::Inventory& _internal_inventory() const;
  ::SaveObject::Inventory* _internal_mutable_inventory();
  public:
  void unsafe_arena_set_allocated_inventory(
      ::SaveObject::Inventory* inventory);
  ::SaveObject::Inventory* unsafe_arena_release_inventory();

  // uint32 level = 2;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // uint32 map = 3;
  void clear_map();
  uint32_t map() const;
  void set_map(uint32_t value);
  private:
  uint32_t _internal_map() const;
  void _internal_set_map(uint32_t value);
  public:

  // float loc_x = 4;
  void clear_loc_x();
  float loc_x() const;
  void set_loc_x(float value);
  private:
  float _internal_loc_x() const;
  void _internal_set_loc_x(float value);
  public:

  // float loc_y = 5;
  void clear_loc_y();
  float loc_y() const;
  void set_loc_y(float value);
  private:
  float _internal_loc_y() const;
  void _internal_set_loc_y(float value);
  public:

  // uint64 gold = 7;
  void clear_gold();
  uint64_t gold() const;
  void set_gold(uint64_t value);
  private:
  uint64_t _internal_gold() const;
  void _internal_set_gold(uint64_t value);
  public:

  // float loc_z = 6;
  void clear_loc_z();
  float loc_z() const;
  void set_loc_z(float value);
  private:
  float _internal_loc_z() const;
  void _internal_set_loc_z(float value);
  public:

  // uint32 slotIndex = 10;
  void clear_slotindex();
  uint32_t slotindex() const;
  void set_slotindex(uint32_t value);
  private:
  uint32_t _internal_slotindex() const;
  void _internal_set_slotindex(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SaveObject.PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::QuestStatus > queststatus_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::SaveObject::Inventory* inventory_;
    uint32_t level_;
    uint32_t map_;
    float loc_x_;
    float loc_y_;
    uint64_t gold_;
    float loc_z_;
    uint32_t slotindex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SaveObject_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GameItem

// uint64 index = 1;
inline void GameItem::clear_index() {
  _impl_.index_ = uint64_t{0u};
}
inline uint64_t GameItem::_internal_index() const {
  return _impl_.index_;
}
inline uint64_t GameItem::index() const {
  // @@protoc_insertion_point(field_get:SaveObject.GameItem.index)
  return _internal_index();
}
inline void GameItem::_internal_set_index(uint64_t value) {
  
  _impl_.index_ = value;
}
inline void GameItem::set_index(uint64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:SaveObject.GameItem.index)
}

// uint64 num = 2;
inline void GameItem::clear_num() {
  _impl_.num_ = uint64_t{0u};
}
inline uint64_t GameItem::_internal_num() const {
  return _impl_.num_;
}
inline uint64_t GameItem::num() const {
  // @@protoc_insertion_point(field_get:SaveObject.GameItem.num)
  return _internal_num();
}
inline void GameItem::_internal_set_num(uint64_t value) {
  
  _impl_.num_ = value;
}
inline void GameItem::set_num(uint64_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:SaveObject.GameItem.num)
}

// -------------------------------------------------------------------

// TypeInventory

// uint32 type = 1;
inline void TypeInventory::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t TypeInventory::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t TypeInventory::type() const {
  // @@protoc_insertion_point(field_get:SaveObject.TypeInventory.type)
  return _internal_type();
}
inline void TypeInventory::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void TypeInventory::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SaveObject.TypeInventory.type)
}

// repeated .SaveObject.GameItem items = 2;
inline int TypeInventory::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int TypeInventory::items_size() const {
  return _internal_items_size();
}
inline void TypeInventory::clear_items() {
  _impl_.items_.Clear();
}
inline ::SaveObject::GameItem* TypeInventory::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:SaveObject.TypeInventory.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::GameItem >*
TypeInventory::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:SaveObject.TypeInventory.items)
  return &_impl_.items_;
}
inline const ::SaveObject::GameItem& TypeInventory::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::SaveObject::GameItem& TypeInventory::items(int index) const {
  // @@protoc_insertion_point(field_get:SaveObject.TypeInventory.items)
  return _internal_items(index);
}
inline ::SaveObject::GameItem* TypeInventory::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::SaveObject::GameItem* TypeInventory::add_items() {
  ::SaveObject::GameItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:SaveObject.TypeInventory.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::GameItem >&
TypeInventory::items() const {
  // @@protoc_insertion_point(field_list:SaveObject.TypeInventory.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// Inventory

// repeated .SaveObject.TypeInventory typeInventory = 1;
inline int Inventory::_internal_typeinventory_size() const {
  return _impl_.typeinventory_.size();
}
inline int Inventory::typeinventory_size() const {
  return _internal_typeinventory_size();
}
inline void Inventory::clear_typeinventory() {
  _impl_.typeinventory_.Clear();
}
inline ::SaveObject::TypeInventory* Inventory::mutable_typeinventory(int index) {
  // @@protoc_insertion_point(field_mutable:SaveObject.Inventory.typeInventory)
  return _impl_.typeinventory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::TypeInventory >*
Inventory::mutable_typeinventory() {
  // @@protoc_insertion_point(field_mutable_list:SaveObject.Inventory.typeInventory)
  return &_impl_.typeinventory_;
}
inline const ::SaveObject::TypeInventory& Inventory::_internal_typeinventory(int index) const {
  return _impl_.typeinventory_.Get(index);
}
inline const ::SaveObject::TypeInventory& Inventory::typeinventory(int index) const {
  // @@protoc_insertion_point(field_get:SaveObject.Inventory.typeInventory)
  return _internal_typeinventory(index);
}
inline ::SaveObject::TypeInventory* Inventory::_internal_add_typeinventory() {
  return _impl_.typeinventory_.Add();
}
inline ::SaveObject::TypeInventory* Inventory::add_typeinventory() {
  ::SaveObject::TypeInventory* _add = _internal_add_typeinventory();
  // @@protoc_insertion_point(field_add:SaveObject.Inventory.typeInventory)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::TypeInventory >&
Inventory::typeinventory() const {
  // @@protoc_insertion_point(field_list:SaveObject.Inventory.typeInventory)
  return _impl_.typeinventory_;
}

// -------------------------------------------------------------------

// QuestStatus_SubQuestStatus

// .SaveObject.QuestStatus.SubQuestStatus.SubQuestType type = 1;
inline void QuestStatus_SubQuestStatus::clear_type() {
  _impl_.type_ = 0;
}
inline ::SaveObject::QuestStatus_SubQuestStatus_SubQuestType QuestStatus_SubQuestStatus::_internal_type() const {
  return static_cast< ::SaveObject::QuestStatus_SubQuestStatus_SubQuestType >(_impl_.type_);
}
inline ::SaveObject::QuestStatus_SubQuestStatus_SubQuestType QuestStatus_SubQuestStatus::type() const {
  // @@protoc_insertion_point(field_get:SaveObject.QuestStatus.SubQuestStatus.type)
  return _internal_type();
}
inline void QuestStatus_SubQuestStatus::_internal_set_type(::SaveObject::QuestStatus_SubQuestStatus_SubQuestType value) {
  
  _impl_.type_ = value;
}
inline void QuestStatus_SubQuestStatus::set_type(::SaveObject::QuestStatus_SubQuestStatus_SubQuestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SaveObject.QuestStatus.SubQuestStatus.type)
}

// bool bStarted = 2;
inline void QuestStatus_SubQuestStatus::clear_bstarted() {
  _impl_.bstarted_ = false;
}
inline bool QuestStatus_SubQuestStatus::_internal_bstarted() const {
  return _impl_.bstarted_;
}
inline bool QuestStatus_SubQuestStatus::bstarted() const {
  // @@protoc_insertion_point(field_get:SaveObject.QuestStatus.SubQuestStatus.bStarted)
  return _internal_bstarted();
}
inline void QuestStatus_SubQuestStatus::_internal_set_bstarted(bool value) {
  
  _impl_.bstarted_ = value;
}
inline void QuestStatus_SubQuestStatus::set_bstarted(bool value) {
  _internal_set_bstarted(value);
  // @@protoc_insertion_point(field_set:SaveObject.QuestStatus.SubQuestStatus.bStarted)
}

// bool bCompleted = 3;
inline void QuestStatus_SubQuestStatus::clear_bcompleted() {
  _impl_.bcompleted_ = false;
}
inline bool QuestStatus_SubQuestStatus::_internal_bcompleted() const {
  return _impl_.bcompleted_;
}
inline bool QuestStatus_SubQuestStatus::bcompleted() const {
  // @@protoc_insertion_point(field_get:SaveObject.QuestStatus.SubQuestStatus.bCompleted)
  return _internal_bcompleted();
}
inline void QuestStatus_SubQuestStatus::_internal_set_bcompleted(bool value) {
  
  _impl_.bcompleted_ = value;
}
inline void QuestStatus_SubQuestStatus::set_bcompleted(bool value) {
  _internal_set_bcompleted(value);
  // @@protoc_insertion_point(field_set:SaveObject.QuestStatus.SubQuestStatus.bCompleted)
}

// uint32 currAmount = 4;
inline void QuestStatus_SubQuestStatus::clear_curramount() {
  _impl_.curramount_ = 0u;
}
inline uint32_t QuestStatus_SubQuestStatus::_internal_curramount() const {
  return _impl_.curramount_;
}
inline uint32_t QuestStatus_SubQuestStatus::curramount() const {
  // @@protoc_insertion_point(field_get:SaveObject.QuestStatus.SubQuestStatus.currAmount)
  return _internal_curramount();
}
inline void QuestStatus_SubQuestStatus::_internal_set_curramount(uint32_t value) {
  
  _impl_.curramount_ = value;
}
inline void QuestStatus_SubQuestStatus::set_curramount(uint32_t value) {
  _internal_set_curramount(value);
  // @@protoc_insertion_point(field_set:SaveObject.QuestStatus.SubQuestStatus.currAmount)
}

// -------------------------------------------------------------------

// QuestStatus

// uint32 index = 1;
inline void QuestStatus::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t QuestStatus::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t QuestStatus::index() const {
  // @@protoc_insertion_point(field_get:SaveObject.QuestStatus.index)
  return _internal_index();
}
inline void QuestStatus::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void QuestStatus::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:SaveObject.QuestStatus.index)
}

// .SaveObject.QuestStatus.QuestType type = 2;
inline void QuestStatus::clear_type() {
  _impl_.type_ = 0;
}
inline ::SaveObject::QuestStatus_QuestType QuestStatus::_internal_type() const {
  return static_cast< ::SaveObject::QuestStatus_QuestType >(_impl_.type_);
}
inline ::SaveObject::QuestStatus_QuestType QuestStatus::type() const {
  // @@protoc_insertion_point(field_get:SaveObject.QuestStatus.type)
  return _internal_type();
}
inline void QuestStatus::_internal_set_type(::SaveObject::QuestStatus_QuestType value) {
  
  _impl_.type_ = value;
}
inline void QuestStatus::set_type(::SaveObject::QuestStatus_QuestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SaveObject.QuestStatus.type)
}

// .SaveObject.QuestStatus.QuestProgressType progressType = 3;
inline void QuestStatus::clear_progresstype() {
  _impl_.progresstype_ = 0;
}
inline ::SaveObject::QuestStatus_QuestProgressType QuestStatus::_internal_progresstype() const {
  return static_cast< ::SaveObject::QuestStatus_QuestProgressType >(_impl_.progresstype_);
}
inline ::SaveObject::QuestStatus_QuestProgressType QuestStatus::progresstype() const {
  // @@protoc_insertion_point(field_get:SaveObject.QuestStatus.progressType)
  return _internal_progresstype();
}
inline void QuestStatus::_internal_set_progresstype(::SaveObject::QuestStatus_QuestProgressType value) {
  
  _impl_.progresstype_ = value;
}
inline void QuestStatus::set_progresstype(::SaveObject::QuestStatus_QuestProgressType value) {
  _internal_set_progresstype(value);
  // @@protoc_insertion_point(field_set:SaveObject.QuestStatus.progressType)
}

// repeated .SaveObject.QuestStatus.SubQuestStatus subStatus = 4;
inline int QuestStatus::_internal_substatus_size() const {
  return _impl_.substatus_.size();
}
inline int QuestStatus::substatus_size() const {
  return _internal_substatus_size();
}
inline void QuestStatus::clear_substatus() {
  _impl_.substatus_.Clear();
}
inline ::SaveObject::QuestStatus_SubQuestStatus* QuestStatus::mutable_substatus(int index) {
  // @@protoc_insertion_point(field_mutable:SaveObject.QuestStatus.subStatus)
  return _impl_.substatus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::QuestStatus_SubQuestStatus >*
QuestStatus::mutable_substatus() {
  // @@protoc_insertion_point(field_mutable_list:SaveObject.QuestStatus.subStatus)
  return &_impl_.substatus_;
}
inline const ::SaveObject::QuestStatus_SubQuestStatus& QuestStatus::_internal_substatus(int index) const {
  return _impl_.substatus_.Get(index);
}
inline const ::SaveObject::QuestStatus_SubQuestStatus& QuestStatus::substatus(int index) const {
  // @@protoc_insertion_point(field_get:SaveObject.QuestStatus.subStatus)
  return _internal_substatus(index);
}
inline ::SaveObject::QuestStatus_SubQuestStatus* QuestStatus::_internal_add_substatus() {
  return _impl_.substatus_.Add();
}
inline ::SaveObject::QuestStatus_SubQuestStatus* QuestStatus::add_substatus() {
  ::SaveObject::QuestStatus_SubQuestStatus* _add = _internal_add_substatus();
  // @@protoc_insertion_point(field_add:SaveObject.QuestStatus.subStatus)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::QuestStatus_SubQuestStatus >&
QuestStatus::substatus() const {
  // @@protoc_insertion_point(field_list:SaveObject.QuestStatus.subStatus)
  return _impl_.substatus_;
}

// uint32 currPhase = 5;
inline void QuestStatus::clear_currphase() {
  _impl_.currphase_ = 0u;
}
inline uint32_t QuestStatus::_internal_currphase() const {
  return _impl_.currphase_;
}
inline uint32_t QuestStatus::currphase() const {
  // @@protoc_insertion_point(field_get:SaveObject.QuestStatus.currPhase)
  return _internal_currphase();
}
inline void QuestStatus::_internal_set_currphase(uint32_t value) {
  
  _impl_.currphase_ = value;
}
inline void QuestStatus::set_currphase(uint32_t value) {
  _internal_set_currphase(value);
  // @@protoc_insertion_point(field_set:SaveObject.QuestStatus.currPhase)
}

// uint32 completed = 6;
inline void QuestStatus::clear_completed() {
  _impl_.completed_ = 0u;
}
inline uint32_t QuestStatus::_internal_completed() const {
  return _impl_.completed_;
}
inline uint32_t QuestStatus::completed() const {
  // @@protoc_insertion_point(field_get:SaveObject.QuestStatus.completed)
  return _internal_completed();
}
inline void QuestStatus::_internal_set_completed(uint32_t value) {
  
  _impl_.completed_ = value;
}
inline void QuestStatus::set_completed(uint32_t value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:SaveObject.QuestStatus.completed)
}

// -------------------------------------------------------------------

// PlayerInfo

// string name = 1;
inline void PlayerInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:SaveObject.PlayerInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SaveObject.PlayerInfo.name)
}
inline std::string* PlayerInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:SaveObject.PlayerInfo.name)
  return _s;
}
inline const std::string& PlayerInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PlayerInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_name() {
  // @@protoc_insertion_point(field_release:SaveObject.PlayerInfo.name)
  return _impl_.name_.Release();
}
inline void PlayerInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SaveObject.PlayerInfo.name)
}

// uint32 level = 2;
inline void PlayerInfo::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t PlayerInfo::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t PlayerInfo::level() const {
  // @@protoc_insertion_point(field_get:SaveObject.PlayerInfo.level)
  return _internal_level();
}
inline void PlayerInfo::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void PlayerInfo::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:SaveObject.PlayerInfo.level)
}

// uint32 map = 3;
inline void PlayerInfo::clear_map() {
  _impl_.map_ = 0u;
}
inline uint32_t PlayerInfo::_internal_map() const {
  return _impl_.map_;
}
inline uint32_t PlayerInfo::map() const {
  // @@protoc_insertion_point(field_get:SaveObject.PlayerInfo.map)
  return _internal_map();
}
inline void PlayerInfo::_internal_set_map(uint32_t value) {
  
  _impl_.map_ = value;
}
inline void PlayerInfo::set_map(uint32_t value) {
  _internal_set_map(value);
  // @@protoc_insertion_point(field_set:SaveObject.PlayerInfo.map)
}

// float loc_x = 4;
inline void PlayerInfo::clear_loc_x() {
  _impl_.loc_x_ = 0;
}
inline float PlayerInfo::_internal_loc_x() const {
  return _impl_.loc_x_;
}
inline float PlayerInfo::loc_x() const {
  // @@protoc_insertion_point(field_get:SaveObject.PlayerInfo.loc_x)
  return _internal_loc_x();
}
inline void PlayerInfo::_internal_set_loc_x(float value) {
  
  _impl_.loc_x_ = value;
}
inline void PlayerInfo::set_loc_x(float value) {
  _internal_set_loc_x(value);
  // @@protoc_insertion_point(field_set:SaveObject.PlayerInfo.loc_x)
}

// float loc_y = 5;
inline void PlayerInfo::clear_loc_y() {
  _impl_.loc_y_ = 0;
}
inline float PlayerInfo::_internal_loc_y() const {
  return _impl_.loc_y_;
}
inline float PlayerInfo::loc_y() const {
  // @@protoc_insertion_point(field_get:SaveObject.PlayerInfo.loc_y)
  return _internal_loc_y();
}
inline void PlayerInfo::_internal_set_loc_y(float value) {
  
  _impl_.loc_y_ = value;
}
inline void PlayerInfo::set_loc_y(float value) {
  _internal_set_loc_y(value);
  // @@protoc_insertion_point(field_set:SaveObject.PlayerInfo.loc_y)
}

// float loc_z = 6;
inline void PlayerInfo::clear_loc_z() {
  _impl_.loc_z_ = 0;
}
inline float PlayerInfo::_internal_loc_z() const {
  return _impl_.loc_z_;
}
inline float PlayerInfo::loc_z() const {
  // @@protoc_insertion_point(field_get:SaveObject.PlayerInfo.loc_z)
  return _internal_loc_z();
}
inline void PlayerInfo::_internal_set_loc_z(float value) {
  
  _impl_.loc_z_ = value;
}
inline void PlayerInfo::set_loc_z(float value) {
  _internal_set_loc_z(value);
  // @@protoc_insertion_point(field_set:SaveObject.PlayerInfo.loc_z)
}

// uint64 gold = 7;
inline void PlayerInfo::clear_gold() {
  _impl_.gold_ = uint64_t{0u};
}
inline uint64_t PlayerInfo::_internal_gold() const {
  return _impl_.gold_;
}
inline uint64_t PlayerInfo::gold() const {
  // @@protoc_insertion_point(field_get:SaveObject.PlayerInfo.gold)
  return _internal_gold();
}
inline void PlayerInfo::_internal_set_gold(uint64_t value) {
  
  _impl_.gold_ = value;
}
inline void PlayerInfo::set_gold(uint64_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:SaveObject.PlayerInfo.gold)
}

// .SaveObject.Inventory inventory = 8;
inline bool PlayerInfo::_internal_has_inventory() const {
  return this != internal_default_instance() && _impl_.inventory_ != nullptr;
}
inline bool PlayerInfo::has_inventory() const {
  return _internal_has_inventory();
}
inline void PlayerInfo::clear_inventory() {
  if (GetArenaForAllocation() == nullptr && _impl_.inventory_ != nullptr) {
    delete _impl_.inventory_;
  }
  _impl_.inventory_ = nullptr;
}
inline const ::SaveObject::Inventory& PlayerInfo::_internal_inventory() const {
  const ::SaveObject::Inventory* p = _impl_.inventory_;
  return p != nullptr ? *p : reinterpret_cast<const ::SaveObject::Inventory&>(
      ::SaveObject::_Inventory_default_instance_);
}
inline const ::SaveObject::Inventory& PlayerInfo::inventory() const {
  // @@protoc_insertion_point(field_get:SaveObject.PlayerInfo.inventory)
  return _internal_inventory();
}
inline void PlayerInfo::unsafe_arena_set_allocated_inventory(
    ::SaveObject::Inventory* inventory) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inventory_);
  }
  _impl_.inventory_ = inventory;
  if (inventory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SaveObject.PlayerInfo.inventory)
}
inline ::SaveObject::Inventory* PlayerInfo::release_inventory() {
  
  ::SaveObject::Inventory* temp = _impl_.inventory_;
  _impl_.inventory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SaveObject::Inventory* PlayerInfo::unsafe_arena_release_inventory() {
  // @@protoc_insertion_point(field_release:SaveObject.PlayerInfo.inventory)
  
  ::SaveObject::Inventory* temp = _impl_.inventory_;
  _impl_.inventory_ = nullptr;
  return temp;
}
inline ::SaveObject::Inventory* PlayerInfo::_internal_mutable_inventory() {
  
  if (_impl_.inventory_ == nullptr) {
    auto* p = CreateMaybeMessage<::SaveObject::Inventory>(GetArenaForAllocation());
    _impl_.inventory_ = p;
  }
  return _impl_.inventory_;
}
inline ::SaveObject::Inventory* PlayerInfo::mutable_inventory() {
  ::SaveObject::Inventory* _msg = _internal_mutable_inventory();
  // @@protoc_insertion_point(field_mutable:SaveObject.PlayerInfo.inventory)
  return _msg;
}
inline void PlayerInfo::set_allocated_inventory(::SaveObject::Inventory* inventory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inventory_;
  }
  if (inventory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inventory);
    if (message_arena != submessage_arena) {
      inventory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inventory, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.inventory_ = inventory;
  // @@protoc_insertion_point(field_set_allocated:SaveObject.PlayerInfo.inventory)
}

// repeated .SaveObject.QuestStatus questStatus = 9;
inline int PlayerInfo::_internal_queststatus_size() const {
  return _impl_.queststatus_.size();
}
inline int PlayerInfo::queststatus_size() const {
  return _internal_queststatus_size();
}
inline void PlayerInfo::clear_queststatus() {
  _impl_.queststatus_.Clear();
}
inline ::SaveObject::QuestStatus* PlayerInfo::mutable_queststatus(int index) {
  // @@protoc_insertion_point(field_mutable:SaveObject.PlayerInfo.questStatus)
  return _impl_.queststatus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::QuestStatus >*
PlayerInfo::mutable_queststatus() {
  // @@protoc_insertion_point(field_mutable_list:SaveObject.PlayerInfo.questStatus)
  return &_impl_.queststatus_;
}
inline const ::SaveObject::QuestStatus& PlayerInfo::_internal_queststatus(int index) const {
  return _impl_.queststatus_.Get(index);
}
inline const ::SaveObject::QuestStatus& PlayerInfo::queststatus(int index) const {
  // @@protoc_insertion_point(field_get:SaveObject.PlayerInfo.questStatus)
  return _internal_queststatus(index);
}
inline ::SaveObject::QuestStatus* PlayerInfo::_internal_add_queststatus() {
  return _impl_.queststatus_.Add();
}
inline ::SaveObject::QuestStatus* PlayerInfo::add_queststatus() {
  ::SaveObject::QuestStatus* _add = _internal_add_queststatus();
  // @@protoc_insertion_point(field_add:SaveObject.PlayerInfo.questStatus)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SaveObject::QuestStatus >&
PlayerInfo::queststatus() const {
  // @@protoc_insertion_point(field_list:SaveObject.PlayerInfo.questStatus)
  return _impl_.queststatus_;
}

// uint32 slotIndex = 10;
inline void PlayerInfo::clear_slotindex() {
  _impl_.slotindex_ = 0u;
}
inline uint32_t PlayerInfo::_internal_slotindex() const {
  return _impl_.slotindex_;
}
inline uint32_t PlayerInfo::slotindex() const {
  // @@protoc_insertion_point(field_get:SaveObject.PlayerInfo.slotIndex)
  return _internal_slotindex();
}
inline void PlayerInfo::_internal_set_slotindex(uint32_t value) {
  
  _impl_.slotindex_ = value;
}
inline void PlayerInfo::set_slotindex(uint32_t value) {
  _internal_set_slotindex(value);
  // @@protoc_insertion_point(field_set:SaveObject.PlayerInfo.slotIndex)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SaveObject

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SaveObject::Inventory_ItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SaveObject::Inventory_ItemType>() {
  return ::SaveObject::Inventory_ItemType_descriptor();
}
template <> struct is_proto_enum< ::SaveObject::QuestStatus_SubQuestStatus_SubQuestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SaveObject::QuestStatus_SubQuestStatus_SubQuestType>() {
  return ::SaveObject::QuestStatus_SubQuestStatus_SubQuestType_descriptor();
}
template <> struct is_proto_enum< ::SaveObject::QuestStatus_QuestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SaveObject::QuestStatus_QuestType>() {
  return ::SaveObject::QuestStatus_QuestType_descriptor();
}
template <> struct is_proto_enum< ::SaveObject::QuestStatus_QuestProgressType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SaveObject::QuestStatus_QuestProgressType>() {
  return ::SaveObject::QuestStatus_QuestProgressType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_SaveObject_2eproto
